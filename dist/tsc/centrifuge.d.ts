import { Subscription } from './subscription';
import { State, Options, ClientEvents, TypedEventEmitter, RpcResult, SubscriptionOptions, HistoryOptions, HistoryResult, PublishResult, PresenceResult, PresenceStatsResult, SubscribedContext } from './types';
declare const Centrifuge_base: new () => TypedEventEmitter<ClientEvents>;
export declare class Centrifuge extends Centrifuge_base {
    state: State;
    private _endpoint;
    private _emulation;
    private _transports;
    private _currentTransportIndex;
    private _triedAllTransports;
    private _transportWasOpen;
    private _transport?;
    private _transportClosed;
    private _encoder;
    private _decoder;
    private _reconnectTimeout?;
    private _reconnectAttempts;
    private _client;
    private _session;
    private _node;
    private _subs;
    private _serverSubs;
    private _commandId;
    private _commands;
    private _batching;
    private _refreshRequired;
    private _refreshTimeout?;
    private _callbacks;
    private _token?;
    private _dispatchPromise;
    private _serverPing;
    private _serverPingTimeout?;
    private _sendPong;
    private _promises;
    private _promiseId;
    _debugEnabled: boolean;
    _config: Options;
    static State: {
        Disconnected: string;
        Connecting: string;
        Connected: string;
    };
    static SubscriptionState: {
        Unsubscribed: string;
        Subscribing: string;
        Subscribed: string;
    };
    constructor(endpoint: string | Array<object>, options?: Partial<Options>);
    newSubscription(channel: string, options?: Partial<SubscriptionOptions>): Subscription;
    getSubscription(channel: string): Subscription | null;
    removeSubscription(sub: Subscription | null): void;
    subscriptions(): Map<string, Subscription>;
    ready(timeout?: number): Promise<unknown>;
    connect(): void;
    disconnect(): void;
    send(data: any): Promise<void>;
    rpc(method: string, data: any): Promise<RpcResult>;
    publish(channel: string, data: any): Promise<PublishResult>;
    history(channel: string, options?: HistoryOptions): Promise<HistoryResult>;
    presence(channel: string): Promise<PresenceResult>;
    presenceStats(channel: string): Promise<PresenceStatsResult>;
    startBatching(): void;
    stopBatching(): void;
    _debug(...args: any[]): void;
    private _setFormat;
    protected _formatOverride(_format: string): boolean;
    private _configure;
    private _setState;
    private _isDisconnected;
    private _isConnecting;
    private _isConnected;
    private _nextCommandId;
    private _getReconnectDelay;
    private _clearOutgoingRequests;
    private _clearConnectedState;
    private _handleWriteError;
    private _transportSendCommands;
    private _initializeTransport;
    private _sendConnect;
    private _startReconnecting;
    private _connectError;
    private _constructConnectCommand;
    private _getHistoryRequest;
    private _methodCall;
    private _callPromise;
    private _dataReceived;
    private _dispatchSynchronized;
    private _dispatchReply;
    _call(cmd: any): Promise<unknown>;
    private _callConnectFake;
    private _startConnecting;
    private _disconnect;
    private _failUnauthorized;
    private _getToken;
    private _refresh;
    private _refreshError;
    private _getRefreshRetryDelay;
    private _refreshResponse;
    _subscribe(sub: any): void;
    private _sendSubscribe;
    _sendSubRefresh(sub: Subscription, token: string): void;
    protected _removeSubscription(sub: Subscription | null): void;
    _unsubscribe(sub: Subscription): void;
    private _getSub;
    private _isServerSub;
    private _connectResponse;
    private _processServerSubs;
    private _clearRefreshTimeout;
    private _clearReconnectTimeout;
    private _clearServerPingTimeout;
    private _waitServerPing;
    private _subscribeError;
    _getSubscribeContext(channel: string, result: any): SubscribedContext;
    private _subscribeResponse;
    private _handleReply;
    private _handleJoin;
    private _handleLeave;
    private _handleUnsubscribe;
    private _handleSubscribe;
    private _handleDisconnect;
    _getPublicationContext(channel: string, pub: any): any;
    _getJoinLeaveContext(clientInfo: any): any;
    private _handlePublication;
    private _handleMessage;
    private _handleServerPing;
    private _handlePush;
    private _flush;
    private _createErrorObject;
    private _registerCall;
    private _addCommand;
    private _nextPromiseId;
    private _resolvePromises;
    private _rejectPromises;
}
export {};
