{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///centrifuge.min.js","webpack:///webpack/bootstrap aad167f0d4f3961f30c4","webpack:///./src/centrifuge.js","webpack:///./src/subscription.js","webpack:///./src/json.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/index.js","webpack:///./node_modules/events/events.js","webpack:///./src/utils.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","10","global","_interopRequireDefault","obj","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","constructor","value","writable","setPrototypeOf","__proto__","Centrifuge","undefined","_typeof","Symbol","iterator","_createClass","defineProperties","target","props","length","descriptor","key","protoProps","staticProps","_events","_events2","_subscription","_subscription2","_json","_utils","_EventEmitter","url","options","_this","getPrototypeOf","_url","_websocket","_sockjs","_isSockjs","_binary","_methodType","_pushType","_encoder","_decoder","_status","_reconnect","_reconnecting","_transport","_transportName","_transportClosed","_messageId","_clientID","_refreshRequired","_subs","_serverSubs","_lastSeq","_lastGen","_lastOffset","_lastEpoch","_messages","_isBatching","_isSubscribeBatching","_privateChannels","_numRefreshFailed","_refreshTimeout","_pingTimeout","_pongTimeout","_subRefreshTimeouts","_retries","_callbacks","_latency","_latencyStart","_connectData","_token","_xhrID","_xhrs","_dispatchPromise","Promise","resolve","_config","debug","websocket","sockjs","promise","minRetry","maxRetry","timeout","ping","pingInterval","pongWaitTimeout","privateChannelPrefix","onTransportClose","sockjsServer","sockjsTransports","refreshEndpoint","refreshHeaders","refreshParams","refreshData","refreshAttempts","refreshInterval","onRefreshFailed","onRefresh","subscribeEndpoint","subscribeHeaders","subscribeParams","subRefreshInterval","onPrivateSubscribe","_configure","token","data","headers","params","callback","_this2","query","_debug","JSON","stringify","xhr","XMLHttpRequest","ActiveXObject","encodeURIComponent","open","withCredentials","setRequestHeader","headerName","onreadystatechange","readyState","status","parsed","parse","responseText","e","error","_log","setTimeout","send","log","arguments","WebSocket","format","_formatOverride","Error","JsonMethodType","JsonPushType","JsonEncoder","JsonDecoder","configuration","extend","startsWith","indexOf","_setFormat","SockJS","newStatus","interval","backoff","xhrID","abort","reconnect","_stopPing","id","callbacks","clearTimeout","errback","_createErrorObject","channel","sub","_isSuccess","_triggerUnsubscribe","_recover","_shouldResubscribe","_setSubscribing","_setUnsubscribed","_abortInflightXHRs","_clearSubRefreshTimeout","transport","OPEN","commands","_isTransportOpen","command","encodeCommands","_this3","sockjsOptions","transports","server","_websocketSupported","binaryType","onopen","onheartbeat","_restartPing","msg","subs","hasSubs","recoverable","recover","seq","gen","offset","epoch","Date","_call","then","resolveCtx","_connectResponse","decodeCommandResult","CONNECT","result","next","rejectCtx","code","_disconnect","onerror","onclose","closeEvent","reason","needReconnect","advice","event","_getRetryInterval","_refresh","_connect","onmessage","_dataReceived","_rpc","method","_this4","RPC","isConnected","reject","SEND","_transportSend","since","limit","_this5","_getHistoryParams","HISTORY","_this6","PUBLISH","_this7","replies","decodeReplies","finishDispatch","_dispatchSynchronized","_this8","_dispatchReply","reply","_handleReply","_handlePush","_this9","_addMessage","_registerCall","_setStatus","_setupTransport","shouldReconnect","_isDisconnected","_clearConnectedState","emit","close","_this10","_refreshFailed","clientID","_newXHRID","cb","resp","jitter","Math","round","random","max","REFRESH","_refreshResponse","_refreshError","context","_ajax","err","_this11","_this12","expires","client","_getTTLMilliseconds","ttl","_this13","channelsData","channels","channelData","SUB_REFRESH","_getSub","_subRefreshResponse","_subRefreshError","_this14","subRefreshTimeout","_subRefresh","_this15","isResubscribe","_this16","_setNew","SUBSCRIBE","startSubscribeBatching","_subscribe","stopSubscribeBatching","_needRecover","_getLastSeq","_getLastGen","_getLastOffset","_getLastEpoch","_subscribeResponse","_subscribeError","UNSUBSCRIBE","min","isRecover","_this17","wasReconnecting","_resetRetry","getTime","startBatching","stopBatching","_startPing","ctx","latency","_processServerSubs","subCtx","_expandSubscribeContext","recovered","pubs","publications","reverse","_handlePublication","_this18","_isSubscribing","message","_setSubscribeError","positioned","streamPosition","_this19","_setSubscribeSuccess","_recoverable","errorExists","join","info","_isServerSub","leave","unsub","unsubscribe","resubscribe","subscribe","pub","push","decodePush","type","PUBLICATION","decodePushData","MESSAGE","_handleMessage","JOIN","_handleJoin","LEAVE","_handleLeave","UNSUB","_handleUnsub","SUB","_handleSub","messages","slice","_this20","PING","_pingResponse","lastSeq","lastOffset","lastGen","lastEpoch","_this21","isFunction","_nextMessageId","_isConnected","_ping","_flush","_this22","authChannels","batch","_ret2","events","currentSub","_setEvents","_isUnsubscribed","Subscription","EventEmitter","11","_STATE_NEW","centrifuge","_centrifuge","_error","_isResubscribe","_ready","_subscriptionPromise","_noResubscribe","_initializePromise","_promises","_promiseId","on","errContext","_resolve","_reject","toString","knownEvents","ev","successContext","_getSubscribeErrorContext","noResubscribe","needTrigger","subscribeResult","subscribeErrorContext","_getSubscribeSuccessContext","_unsubscribe","subPromise","_isError","res","rej","_nextPromiseId","_methodCall","PRESENCE","PRESENCE_STATS","12","encodedCommands","encodedReplies","split","methodType","pushType","3","g","Function","eval","window","31","6","ProcessEmitWarning","warning","console","warn","init","$getMaxListeners","that","_maxListeners","defaultMaxListeners","_addListener","listener","prepend","existing","_eventsCount","newListener","unshift","warned","w","String","emitter","count","onceWrapper","args","fired","removeListener","wrapFn","ReflectApply","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","unwrapListeners","arrayClone","listenerCount","arr","copy","Array","spliceOne","list","index","pop","ret","ReflectOwnKeys","R","Reflect","apply","receiver","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","set","arg","RangeError","setMaxListeners","getMaxListeners","doError","er","handler","len","listeners","addListener","prependListener","once","prependOnceListener","position","originalListener","shift","off","removeAllListeners","keys","rawListeners","eventNames","7","prefix","lastIndexOf","level","logger","step","pow","floor","a","b"],"mappings":"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","file":"centrifuge.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Centrifuge\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Centrifuge\"] = factory();\n\telse\n\t\troot[\"Centrifuge\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Centrifuge\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Centrifuge\"] = factory();\n\telse\n\t\troot[\"Centrifuge\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 31);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 10:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Centrifuge = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(6);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _subscription = __webpack_require__(11);\n\nvar _subscription2 = _interopRequireDefault(_subscription);\n\nvar _json = __webpack_require__(12);\n\nvar _utils = __webpack_require__(7);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _errorTimeout = 'timeout';\nvar _errorConnectionClosed = 'connection closed';\n\nvar Centrifuge = exports.Centrifuge = function (_EventEmitter) {\n  _inherits(Centrifuge, _EventEmitter);\n\n  function Centrifuge(url, options) {\n    _classCallCheck(this, Centrifuge);\n\n    var _this = _possibleConstructorReturn(this, (Centrifuge.__proto__ || Object.getPrototypeOf(Centrifuge)).call(this));\n\n    _this._url = url;\n    _this._websocket = null;\n    _this._sockjs = null;\n    _this._isSockjs = false;\n    _this._binary = false;\n    _this._methodType = null;\n    _this._pushType = null;\n    _this._encoder = null;\n    _this._decoder = null;\n    _this._status = 'disconnected';\n    _this._reconnect = true;\n    _this._reconnecting = false;\n    _this._transport = null;\n    _this._transportName = null;\n    _this._transportClosed = true;\n    _this._messageId = 0;\n    _this._clientID = null;\n    _this._refreshRequired = false;\n    _this._subs = {};\n    _this._serverSubs = {};\n    _this._lastSeq = {};\n    _this._lastGen = {};\n    _this._lastOffset = {};\n    _this._lastEpoch = {};\n    _this._messages = [];\n    _this._isBatching = false;\n    _this._isSubscribeBatching = false;\n    _this._privateChannels = {};\n    _this._numRefreshFailed = 0;\n    _this._refreshTimeout = null;\n    _this._pingTimeout = null;\n    _this._pongTimeout = null;\n    _this._subRefreshTimeouts = {};\n    _this._retries = 0;\n    _this._callbacks = {};\n    _this._latency = null;\n    _this._latencyStart = null;\n    _this._connectData = null;\n    _this._token = null;\n    _this._xhrID = 0;\n    _this._xhrs = {};\n    _this._dispatchPromise = Promise.resolve();\n    _this._config = {\n      debug: false,\n      websocket: null,\n      sockjs: null,\n      promise: null,\n      minRetry: 1000,\n      maxRetry: 20000,\n      timeout: 5000,\n      ping: true,\n      pingInterval: 25000,\n      pongWaitTimeout: 5000,\n      privateChannelPrefix: '$',\n      onTransportClose: null,\n      sockjsServer: null,\n      sockjsTransports: ['websocket', 'xdr-streaming', 'xhr-streaming', 'eventsource', 'iframe-eventsource', 'iframe-htmlfile', 'xdr-polling', 'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling'],\n      refreshEndpoint: '/centrifuge/refresh',\n      refreshHeaders: {},\n      refreshParams: {},\n      refreshData: {},\n      refreshAttempts: null,\n      refreshInterval: 1000,\n      onRefreshFailed: null,\n      onRefresh: null,\n      subscribeEndpoint: '/centrifuge/subscribe',\n      subscribeHeaders: {},\n      subscribeParams: {},\n      subRefreshInterval: 1000,\n      onPrivateSubscribe: null\n    };\n    _this._configure(options);\n    return _this;\n  }\n\n  _createClass(Centrifuge, [{\n    key: 'setToken',\n    value: function setToken(token) {\n      this._token = token;\n    }\n  }, {\n    key: 'setConnectData',\n    value: function setConnectData(data) {\n      this._connectData = data;\n    }\n  }, {\n    key: 'setRefreshHeaders',\n    value: function setRefreshHeaders(headers) {\n      this._config.refreshHeaders = headers;\n    }\n  }, {\n    key: 'setRefreshParams',\n    value: function setRefreshParams(params) {\n      this._config.refreshParams = params;\n    }\n  }, {\n    key: 'setRefreshData',\n    value: function setRefreshData(data) {\n      this._config.refreshData = data;\n    }\n  }, {\n    key: 'setSubscribeHeaders',\n    value: function setSubscribeHeaders(headers) {\n      this._config.subscribeHeaders = headers;\n    }\n  }, {\n    key: 'setSubscribeParams',\n    value: function setSubscribeParams(params) {\n      this._config.subscribeParams = params;\n    }\n  }, {\n    key: '_ajax',\n    value: function _ajax(url, params, headers, data, callback) {\n      var _this2 = this;\n\n      var query = '';\n      this._debug('sending AJAX request to', url, 'with data', JSON.stringify(data));\n\n      var xhr = global.XMLHttpRequest ? new global.XMLHttpRequest() : new global.ActiveXObject('Microsoft.XMLHTTP');\n\n      for (var i in params) {\n        if (params.hasOwnProperty(i)) {\n          if (query.length > 0) {\n            query += '&';\n          }\n          query += encodeURIComponent(i) + '=' + encodeURIComponent(params[i]);\n        }\n      }\n      if (query.length > 0) {\n        query = '?' + query;\n      }\n      xhr.open('POST', url + query, true);\n      if ('withCredentials' in xhr) {\n        xhr.withCredentials = true;\n      }\n\n      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n      xhr.setRequestHeader('Content-Type', 'application/json');\n      for (var headerName in headers) {\n        if (headers.hasOwnProperty(headerName)) {\n          xhr.setRequestHeader(headerName, headers[headerName]);\n        }\n      }\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n          if (xhr.status === 200) {\n            var _data = void 0,\n                parsed = false;\n            try {\n              _data = JSON.parse(xhr.responseText);\n              parsed = true;\n            } catch (e) {\n              callback({\n                error: 'Invalid JSON. Data was: ' + xhr.responseText,\n                status: 200,\n                data: null\n              });\n            }\n            if (parsed) {\n              // prevents double execution.\n              callback({\n                data: _data,\n                status: 200\n              });\n            }\n          } else {\n            _this2._log('wrong status code in AJAX response', xhr.status);\n            callback({\n              status: xhr.status,\n              data: null\n            });\n          }\n        }\n      };\n      setTimeout(function () {\n        return xhr.send(JSON.stringify(data));\n      }, 20);\n      return xhr;\n    }\n  }, {\n    key: '_log',\n    value: function _log() {\n      (0, _utils.log)('info', arguments);\n    }\n  }, {\n    key: '_debug',\n    value: function _debug() {\n      if (this._config.debug === true) {\n        (0, _utils.log)('debug', arguments);\n      }\n    }\n  }, {\n    key: '_websocketSupported',\n    value: function _websocketSupported() {\n      if (this._config.websocket !== null) {\n        return true;\n      }\n      return !(typeof WebSocket !== 'function' && (typeof WebSocket === 'undefined' ? 'undefined' : _typeof(WebSocket)) !== 'object');\n    }\n  }, {\n    key: '_setFormat',\n    value: function _setFormat(format) {\n      if (this._formatOverride(format)) {\n        return;\n      }\n      if (format === 'protobuf') {\n        throw new Error('not implemented by JSON only Centrifuge client – use client with Protobuf');\n      }\n      this._binary = false;\n      this._methodType = _json.JsonMethodType;\n      this._pushType = _json.JsonPushType;\n      this._encoder = new _json.JsonEncoder();\n      this._decoder = new _json.JsonDecoder();\n    }\n  }, {\n    key: '_formatOverride',\n    value: function _formatOverride(format) {\n      return false;\n    }\n  }, {\n    key: '_configure',\n    value: function _configure(configuration) {\n      if (!('Promise' in global)) {\n        throw new Error('Promise polyfill required');\n      }\n\n      (0, _utils.extend)(this._config, configuration || {});\n      this._debug('centrifuge config', this._config);\n\n      if (!this._url) {\n        throw new Error('url required');\n      }\n\n      if ((0, _utils.startsWith)(this._url, 'ws') && this._url.indexOf('format=protobuf') > -1) {\n        this._setFormat('protobuf');\n      } else {\n        this._setFormat('json');\n      }\n\n      if ((0, _utils.startsWith)(this._url, 'http')) {\n        this._debug('client will try to connect to SockJS endpoint');\n        if (this._config.sockjs !== null) {\n          this._debug('SockJS explicitly provided in options');\n          this._sockjs = this._config.sockjs;\n        } else {\n          if (typeof global.SockJS === 'undefined') {\n            throw new Error('SockJS not found, use ws:// in url or include SockJS');\n          }\n          this._debug('use globally defined SockJS');\n          this._sockjs = global.SockJS;\n        }\n      } else {\n        this._debug('client will connect to websocket endpoint');\n      }\n    }\n  }, {\n    key: '_setStatus',\n    value: function _setStatus(newStatus) {\n      if (this._status !== newStatus) {\n        this._debug('Status', this._status, '->', newStatus);\n        this._status = newStatus;\n      }\n    }\n  }, {\n    key: '_isDisconnected',\n    value: function _isDisconnected() {\n      return this._status === 'disconnected';\n    }\n  }, {\n    key: '_isConnecting',\n    value: function _isConnecting() {\n      return this._status === 'connecting';\n    }\n  }, {\n    key: '_isConnected',\n    value: function _isConnected() {\n      return this._status === 'connected';\n    }\n  }, {\n    key: '_nextMessageId',\n    value: function _nextMessageId() {\n      return ++this._messageId;\n    }\n  }, {\n    key: '_resetRetry',\n    value: function _resetRetry() {\n      this._debug('reset retries count to 0');\n      this._retries = 0;\n    }\n  }, {\n    key: '_getRetryInterval',\n    value: function _getRetryInterval() {\n      var interval = (0, _utils.backoff)(this._retries, this._config.minRetry, this._config.maxRetry);\n\n      this._retries += 1;\n      return interval;\n    }\n  }, {\n    key: '_abortInflightXHRs',\n    value: function _abortInflightXHRs() {\n      for (var xhrID in this._xhrs) {\n        try {\n          this._xhrs[xhrID].abort();\n        } catch (e) {\n          this._debug('error aborting xhr', e);\n        }\n        delete this._xhrs[xhrID];\n      }\n    }\n  }, {\n    key: '_clearConnectedState',\n    value: function _clearConnectedState(reconnect) {\n      this._clientID = null;\n      this._stopPing();\n\n      // fire errbacks of registered outgoing calls.\n      for (var id in this._callbacks) {\n        if (this._callbacks.hasOwnProperty(id)) {\n          var callbacks = this._callbacks[id];\n          clearTimeout(callbacks.timeout);\n          var errback = callbacks.errback;\n          if (!errback) {\n            continue;\n          }\n          errback({ error: this._createErrorObject('disconnected') });\n        }\n      }\n      this._callbacks = {};\n\n      // fire unsubscribe events\n      for (var channel in this._subs) {\n        if (this._subs.hasOwnProperty(channel)) {\n          var sub = this._subs[channel];\n\n          if (reconnect) {\n            if (sub._isSuccess()) {\n              sub._triggerUnsubscribe();\n              sub._recover = true;\n            }\n            if (sub._shouldResubscribe()) {\n              sub._setSubscribing();\n            }\n          } else {\n            sub._setUnsubscribed();\n          }\n        }\n      }\n\n      this._abortInflightXHRs();\n\n      // clear refresh timer\n      if (this._refreshTimeout !== null) {\n        clearTimeout(this._refreshTimeout);\n        this._refreshTimeout = null;\n      }\n\n      // clear sub refresh timers\n      for (var _channel in this._subRefreshTimeouts) {\n        if (this._subRefreshTimeouts.hasOwnProperty(_channel) && this._subRefreshTimeouts[_channel]) {\n          this._clearSubRefreshTimeout(_channel);\n        }\n      }\n      this._subRefreshTimeouts = {};\n\n      if (!this._reconnect) {\n        // completely clear subscriptions\n        this._subs = {};\n      }\n    }\n  }, {\n    key: '_isTransportOpen',\n    value: function _isTransportOpen() {\n      if (this._isSockjs) {\n        return this._transport && this._transport.transport && this._transport.transport.readyState === this._transport.transport.OPEN;\n      }\n      return this._transport && this._transport.readyState === this._transport.OPEN;\n    }\n  }, {\n    key: '_transportSend',\n    value: function _transportSend(commands) {\n      if (!commands.length) {\n        return true;\n      }\n\n      if (!this._isTransportOpen()) {\n        // resolve pending commands with error if transport is not open\n        for (var command in commands) {\n          var id = command.id;\n          if (!(id in this._callbacks)) {\n            continue;\n          }\n          var callbacks = this._callbacks[id];\n          clearTimeout(this._callbacks[id].timeout);\n          delete this._callbacks[id];\n          var errback = callbacks.errback;\n          errback({ error: this._createErrorObject(_errorConnectionClosed, 0) });\n        }\n        return false;\n      }\n      this._transport.send(this._encoder.encodeCommands(commands));\n      return true;\n    }\n  }, {\n    key: '_setupTransport',\n    value: function _setupTransport() {\n      var _this3 = this;\n\n      this._isSockjs = false;\n\n      // detect transport to use - SockJS or Websocket\n      if (this._sockjs !== null) {\n        var sockjsOptions = {\n          transports: this._config.sockjsTransports\n        };\n\n        if (this._config.sockjsServer !== null) {\n          sockjsOptions.server = this._config.sockjsServer;\n        }\n        this._isSockjs = true;\n        this._transport = new this._sockjs(this._url, null, sockjsOptions);\n      } else {\n        if (!this._websocketSupported()) {\n          this._debug('No Websocket support and no SockJS configured, can not connect');\n          return;\n        }\n        if (this._config.websocket !== null) {\n          this._websocket = this._config.websocket;\n        } else {\n          this._websocket = WebSocket;\n        }\n        this._transport = new this._websocket(this._url);\n        if (this._binary === true) {\n          this._transport.binaryType = 'arraybuffer';\n        }\n      }\n\n      this._transport.onopen = function () {\n        _this3._transportClosed = false;\n\n        if (_this3._isSockjs) {\n          _this3._transportName = 'sockjs-' + _this3._transport.transport;\n          _this3._transport.onheartbeat = function () {\n            return _this3._restartPing();\n          };\n        } else {\n          _this3._transportName = 'websocket';\n        }\n\n        // Can omit method here due to zero value.\n        var msg = {\n          // method: this._methodType.CONNECT\n        };\n\n        if (_this3._token || _this3._connectData) {\n          msg.params = {};\n        }\n\n        if (_this3._token) {\n          msg.params.token = _this3._token;\n        }\n\n        if (_this3._connectData) {\n          msg.params.data = _this3._connectData;\n        }\n\n        var subs = {};\n        var hasSubs = false;\n        for (var channel in _this3._serverSubs) {\n          if (_this3._serverSubs.hasOwnProperty(channel) && _this3._serverSubs[channel].recoverable) {\n            hasSubs = true;\n            var sub = {\n              'recover': true\n            };\n            if (_this3._serverSubs[channel].seq || _this3._serverSubs[channel].gen) {\n              if (_this3._serverSubs[channel].seq) {\n                sub['seq'] = _this3._serverSubs[channel].seq;\n              }\n              if (_this3._serverSubs[channel].gen) {\n                sub['gen'] = _this3._serverSubs[channel].gen;\n              }\n            } else {\n              if (_this3._serverSubs[channel].offset) {\n                sub['offset'] = _this3._serverSubs[channel].offset;\n              }\n            }\n            if (_this3._serverSubs[channel].epoch) {\n              sub['epoch'] = _this3._serverSubs[channel].epoch;\n            }\n            subs[channel] = sub;\n          }\n        }\n        if (hasSubs) {\n          if (!msg.params) {\n            msg.params = {};\n          }\n          msg.params.subs = subs;\n        }\n\n        _this3._latencyStart = new Date();\n        _this3._call(msg).then(function (resolveCtx) {\n          _this3._connectResponse(_this3._decoder.decodeCommandResult(_this3._methodType.CONNECT, resolveCtx.result), hasSubs);\n          if (resolveCtx.next) {\n            resolveCtx.next();\n          }\n        }, function (rejectCtx) {\n          var err = rejectCtx.error;\n          if (err.code === 109) {\n            // token expired.\n            _this3._refreshRequired = true;\n          }\n          _this3._disconnect('connect error', true);\n          if (rejectCtx.next) {\n            rejectCtx.next();\n          }\n        });\n      };\n\n      this._transport.onerror = function (error) {\n        _this3._debug('transport level error', error);\n      };\n\n      this._transport.onclose = function (closeEvent) {\n        _this3._transportClosed = true;\n        var reason = _errorConnectionClosed;\n        var needReconnect = true;\n\n        if (closeEvent && 'reason' in closeEvent && closeEvent.reason) {\n          try {\n            var advice = JSON.parse(closeEvent.reason);\n            _this3._debug('reason is an advice object', advice);\n            reason = advice.reason;\n            needReconnect = advice.reconnect;\n          } catch (e) {\n            reason = closeEvent.reason;\n            _this3._debug('reason is a plain string', reason);\n          }\n        }\n\n        // onTransportClose callback should be executed every time transport was closed.\n        // This can be helpful to catch failed connection events (because our disconnect\n        // event only called once and every future attempts to connect do not fire disconnect\n        // event again).\n        if (_this3._config.onTransportClose !== null) {\n          _this3._config.onTransportClose({\n            event: closeEvent,\n            reason: reason,\n            reconnect: needReconnect\n          });\n        }\n\n        _this3._disconnect(reason, needReconnect);\n\n        if (_this3._reconnect === true) {\n          _this3._reconnecting = true;\n          var interval = _this3._getRetryInterval();\n\n          _this3._debug('reconnect after ' + interval + ' milliseconds');\n          setTimeout(function () {\n            if (_this3._reconnect === true) {\n              if (_this3._refreshRequired) {\n                _this3._refresh();\n              } else {\n                _this3._connect();\n              }\n            }\n          }, interval);\n        }\n      };\n\n      this._transport.onmessage = function (event) {\n        _this3._dataReceived(event.data);\n      };\n    }\n  }, {\n    key: 'rpc',\n    value: function rpc(data) {\n      return this._rpc('', data);\n    }\n  }, {\n    key: 'namedRPC',\n    value: function namedRPC(method, data) {\n      return this._rpc(method, data);\n    }\n  }, {\n    key: '_rpc',\n    value: function _rpc(method, data) {\n      var _this4 = this;\n\n      var params = {\n        data: data\n      };\n      if (method !== '') {\n        params.method = method;\n      };\n      var msg = {\n        method: this._methodType.RPC,\n        params: params\n      };\n\n      if (!this.isConnected()) {\n        return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n      }\n\n      return this._call(msg).then(function (resolveCtx) {\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n        return _this4._decoder.decodeCommandResult(_this4._methodType.RPC, resolveCtx.result);\n      }, function (rejectCtx) {\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n        return Promise.reject(rejectCtx.error);\n      });\n    }\n  }, {\n    key: 'send',\n    value: function send(data) {\n      var msg = {\n        method: this._methodType.SEND,\n        params: {\n          data: data\n        }\n      };\n\n      if (!this.isConnected()) {\n        return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n      }\n\n      var sent = this._transportSend([msg]); // can send async message to server without id set\n      if (!sent) {\n        return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n      };\n      return Promise.resolve({});\n    }\n  }, {\n    key: '_getHistoryParams',\n    value: function _getHistoryParams(channel, options) {\n      var params = {\n        channel: channel\n      };\n      if (options !== undefined) {\n        if (options.since) {\n          params['use_since'] = true;\n          if (options.since.offset) {\n            params['offset'] = options.since.offset;\n          }\n          if (options.since.epoch) {\n            params['epoch'] = options.since.epoch;\n          }\n        };\n        if (options.limit !== undefined) {\n          params['use_limit'] = true;\n          params['limit'] = options.limit;\n        }\n      };\n      return params;\n    }\n  }, {\n    key: 'history',\n    value: function history(channel, options) {\n      var _this5 = this;\n\n      var params = this._getHistoryParams(channel, options);\n      var msg = {\n        method: this._methodType.HISTORY,\n        params: params\n      };\n\n      if (!this.isConnected()) {\n        return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n      }\n\n      return new Promise(function (resolve, reject) {\n        _this5._call(msg).then(function (resolveCtx) {\n          resolve(resolveCtx.result);\n          if (resolveCtx.next) {\n            resolveCtx.next();\n          }\n        }, function (rejectCtx) {\n          reject(rejectCtx.error);\n          if (rejectCtx.next) {\n            rejectCtx.next();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'publish',\n    value: function publish(channel, data) {\n      var _this6 = this;\n\n      var msg = {\n        method: this._methodType.PUBLISH,\n        params: {\n          channel: channel,\n          data: data\n        }\n      };\n\n      if (!this.isConnected()) {\n        return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n      }\n\n      return new Promise(function (resolve, reject) {\n        _this6._call(msg).then(function (resolveCtx) {\n          resolve({});\n          if (resolveCtx.next) {\n            resolveCtx.next();\n          }\n        }, function (rejectCtx) {\n          reject(rejectCtx.error);\n          if (rejectCtx.next) {\n            rejectCtx.next();\n          }\n        });\n      });\n    }\n  }, {\n    key: '_dataReceived',\n    value: function _dataReceived(data) {\n      var _this7 = this;\n\n      var replies = this._decoder.decodeReplies(data);\n      // we have to guarantee order of events in replies processing - i.e. start processing\n      // next reply only when we finished processing of current one. Without syncing things in\n      // this way we could get wrong publication events order as reply promises resolve\n      // on next loop tick so for loop continues before we finished emitting all reply events.\n      this._dispatchPromise = this._dispatchPromise.then(function () {\n        var finishDispatch = void 0;\n        _this7._dispatchPromise = new Promise(function (resolve) {\n          finishDispatch = resolve;\n        });\n        _this7._dispatchSynchronized(replies, finishDispatch);\n      });\n      this._restartPing();\n    }\n  }, {\n    key: '_dispatchSynchronized',\n    value: function _dispatchSynchronized(replies, finishDispatch) {\n      var _this8 = this;\n\n      var p = Promise.resolve();\n\n      var _loop = function _loop(i) {\n        if (replies.hasOwnProperty(i)) {\n          p = p.then(function () {\n            return _this8._dispatchReply(replies[i]);\n          });\n        }\n      };\n\n      for (var i in replies) {\n        _loop(i);\n      }\n      p = p.then(function () {\n        finishDispatch();\n      });\n    }\n  }, {\n    key: '_dispatchReply',\n    value: function _dispatchReply(reply) {\n      var next;\n      var p = new Promise(function (resolve) {\n        next = resolve;\n      });\n\n      if (reply === undefined || reply === null) {\n        this._debug('dispatch: got undefined or null reply');\n        next();\n        return p;\n      }\n\n      var id = reply.id;\n\n      if (id && id > 0) {\n        this._handleReply(reply, next);\n      } else {\n        this._handlePush(reply.result, next);\n      }\n\n      return p;\n    }\n  }, {\n    key: '_call',\n    value: function _call(msg) {\n      var _this9 = this;\n\n      return new Promise(function (resolve, reject) {\n        var id = _this9._addMessage(msg);\n        _this9._registerCall(id, resolve, reject);\n      });\n    }\n  }, {\n    key: '_connect',\n    value: function _connect() {\n      if (this.isConnected()) {\n        this._debug('connect called when already connected');\n        return;\n      }\n      if (this._status === 'connecting') {\n        return;\n      }\n\n      this._debug('start connecting');\n      this._setStatus('connecting');\n      this._clientID = null;\n      this._reconnect = true;\n      this._setupTransport();\n    }\n  }, {\n    key: '_disconnect',\n    value: function _disconnect(reason, shouldReconnect) {\n\n      var reconnect = shouldReconnect || false;\n      if (reconnect === false) {\n        this._reconnect = false;\n      }\n\n      if (this._isDisconnected()) {\n        if (!reconnect) {\n          this._clearConnectedState(reconnect);\n        }\n        return;\n      }\n\n      this._clearConnectedState(reconnect);\n\n      this._debug('disconnected:', reason, shouldReconnect);\n      this._setStatus('disconnected');\n\n      if (this._refreshTimeout) {\n        clearTimeout(this._refreshTimeout);\n        this._refreshTimeout = null;\n      }\n      if (this._reconnecting === false) {\n        // fire unsubscribe events for server side subs.\n        for (var channel in this._serverSubs) {\n          if (this._serverSubs.hasOwnProperty(channel)) {\n            this.emit('unsubscribe', { channel: channel });\n          }\n        }\n        this.emit('disconnect', {\n          reason: reason,\n          reconnect: reconnect\n        });\n      }\n\n      if (reconnect === false) {\n        this._subs = {};\n        this._serverSubs = {};\n      }\n\n      if (!this._transportClosed) {\n        this._transport.close();\n      }\n    }\n  }, {\n    key: '_refreshFailed',\n    value: function _refreshFailed() {\n      this._numRefreshFailed = 0;\n      if (!this._isDisconnected()) {\n        this._disconnect('refresh failed', false);\n      }\n      if (this._config.onRefreshFailed !== null) {\n        this._config.onRefreshFailed();\n      }\n    }\n  }, {\n    key: '_refresh',\n    value: function _refresh() {\n      var _this10 = this;\n\n      // ask application for new connection token.\n      this._debug('refresh token');\n\n      if (this._config.refreshAttempts === 0) {\n        this._debug('refresh attempts set to 0, do not send refresh request at all');\n        this._refreshFailed();\n        return;\n      }\n\n      if (this._refreshTimeout !== null) {\n        clearTimeout(this._refreshTimeout);\n        this._refreshTimeout = null;\n      }\n\n      var clientID = this._clientID;\n      var xhrID = this._newXHRID();\n\n      var cb = function cb(resp) {\n        if (xhrID in _this10._xhrs) {\n          delete _this10._xhrs[xhrID];\n        }\n        if (_this10._clientID !== clientID) {\n          return;\n        }\n        if (resp.error || resp.status !== 200) {\n          // We don't perform any connection status related actions here as we are\n          // relying on server that must close connection eventually.\n          if (resp.error) {\n            _this10._debug('error refreshing connection token', resp.error);\n          } else {\n            _this10._debug('error refreshing connection token: wrong status code', resp.status);\n          }\n          _this10._numRefreshFailed++;\n          if (_this10._refreshTimeout !== null) {\n            clearTimeout(_this10._refreshTimeout);\n            _this10._refreshTimeout = null;\n          }\n          if (_this10._config.refreshAttempts !== null && _this10._numRefreshFailed >= _this10._config.refreshAttempts) {\n            _this10._refreshFailed();\n            return;\n          }\n          var jitter = Math.round(Math.random() * 1000 * Math.max(_this10._numRefreshFailed, 20));\n          var interval = _this10._config.refreshInterval + jitter;\n          _this10._refreshTimeout = setTimeout(function () {\n            return _this10._refresh();\n          }, interval);\n          return;\n        }\n        _this10._numRefreshFailed = 0;\n        _this10._token = resp.data.token;\n        if (!_this10._token) {\n          _this10._refreshFailed();\n          return;\n        }\n        if (_this10._isDisconnected() && _this10._reconnect) {\n          _this10._debug('token refreshed, connect from scratch');\n          _this10._connect();\n        } else {\n          _this10._debug('send refreshed token');\n          var msg = {\n            method: _this10._methodType.REFRESH,\n            params: {\n              token: _this10._token\n            }\n          };\n          _this10._call(msg).then(function (resolveCtx) {\n            _this10._refreshResponse(_this10._decoder.decodeCommandResult(_this10._methodType.REFRESH, resolveCtx.result));\n            if (resolveCtx.next) {\n              resolveCtx.next();\n            }\n          }, function (rejectCtx) {\n            _this10._refreshError(rejectCtx.error);\n            if (rejectCtx.next) {\n              rejectCtx.next();\n            }\n          });\n        }\n      };\n\n      if (this._config.onRefresh !== null) {\n        var context = {};\n        this._config.onRefresh(context, cb);\n      } else {\n        var xhr = this._ajax(this._config.refreshEndpoint, this._config.refreshParams, this._config.refreshHeaders, this._config.refreshData, cb);\n        this._xhrs[xhrID] = xhr;\n      }\n    }\n  }, {\n    key: '_refreshError',\n    value: function _refreshError(err) {\n      var _this11 = this;\n\n      this._debug('refresh error', err);\n      if (this._refreshTimeout) {\n        clearTimeout(this._refreshTimeout);\n        this._refreshTimeout = null;\n      }\n      var interval = this._config.refreshInterval + Math.round(Math.random() * 1000);\n      this._refreshTimeout = setTimeout(function () {\n        return _this11._refresh();\n      }, interval);\n    }\n  }, {\n    key: '_refreshResponse',\n    value: function _refreshResponse(result) {\n      var _this12 = this;\n\n      if (this._refreshTimeout) {\n        clearTimeout(this._refreshTimeout);\n        this._refreshTimeout = null;\n      }\n      if (result.expires) {\n        this._clientID = result.client;\n        this._refreshTimeout = setTimeout(function () {\n          return _this12._refresh();\n        }, this._getTTLMilliseconds(result.ttl));\n      }\n    }\n  }, {\n    key: '_newXHRID',\n    value: function _newXHRID() {\n      this._xhrID++;\n      return this._xhrID;\n    }\n  }, {\n    key: '_subRefresh',\n    value: function _subRefresh(channel) {\n      var _this13 = this;\n\n      this._debug('refresh subscription token for channel', channel);\n\n      if (this._subRefreshTimeouts[channel] !== undefined) {\n        this._clearSubRefreshTimeout(channel);\n      } else {\n        return;\n      }\n\n      var clientID = this._clientID;\n      var xhrID = this._newXHRID();\n\n      var cb = function cb(resp) {\n        if (xhrID in _this13._xhrs) {\n          delete _this13._xhrs[xhrID];\n        }\n        if (resp.error || resp.status !== 200 || _this13._clientID !== clientID) {\n          return;\n        }\n        var channelsData = {};\n        if (resp.data.channels) {\n          for (var i in resp.data.channels) {\n            var channelData = resp.data.channels[i];\n            if (!channelData.channel) {\n              continue;\n            }\n            channelsData[channelData.channel] = channelData.token;\n          }\n        }\n\n        var token = channelsData[channel];\n        if (!token) {\n          return;\n        }\n        var msg = {\n          method: _this13._methodType.SUB_REFRESH,\n          params: {\n            channel: channel,\n            token: token\n          }\n        };\n\n        var sub = _this13._getSub(channel);\n        if (sub === null) {\n          return;\n        }\n\n        _this13._call(msg).then(function (resolveCtx) {\n          _this13._subRefreshResponse(channel, _this13._decoder.decodeCommandResult(_this13._methodType.SUB_REFRESH, resolveCtx.result));\n          if (resolveCtx.next) {\n            resolveCtx.next();\n          }\n        }, function (rejectCtx) {\n          _this13._subRefreshError(channel, rejectCtx.error);\n          if (rejectCtx.next) {\n            rejectCtx.next();\n          }\n        });\n      };\n\n      var data = {\n        client: this._clientID,\n        channels: [channel]\n      };\n\n      if (this._config.onPrivateSubscribe !== null) {\n        this._config.onPrivateSubscribe({\n          data: data\n        }, cb);\n      } else {\n        var xhr = this._ajax(this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n        this._xhrs[xhrID] = xhr;\n      }\n    }\n  }, {\n    key: '_clearSubRefreshTimeout',\n    value: function _clearSubRefreshTimeout(channel) {\n      if (this._subRefreshTimeouts[channel] !== undefined) {\n        clearTimeout(this._subRefreshTimeouts[channel]);\n        delete this._subRefreshTimeouts[channel];\n      }\n    }\n  }, {\n    key: '_subRefreshError',\n    value: function _subRefreshError(channel, err) {\n      var _this14 = this;\n\n      this._debug('subscription refresh error', channel, err);\n      this._clearSubRefreshTimeout(channel);\n      var sub = this._getSub(channel);\n      if (sub === null) {\n        return;\n      }\n      var jitter = Math.round(Math.random() * 1000);\n      var subRefreshTimeout = setTimeout(function () {\n        return _this14._subRefresh(channel);\n      }, this._config.subRefreshInterval + jitter);\n      this._subRefreshTimeouts[channel] = subRefreshTimeout;\n      return;\n    }\n  }, {\n    key: '_subRefreshResponse',\n    value: function _subRefreshResponse(channel, result) {\n      var _this15 = this;\n\n      this._debug('subscription refresh success', channel);\n      this._clearSubRefreshTimeout(channel);\n      var sub = this._getSub(channel);\n      if (sub === null) {\n        return;\n      }\n      if (result.expires === true) {\n        var subRefreshTimeout = setTimeout(function () {\n          return _this15._subRefresh(channel);\n        }, this._getTTLMilliseconds(result.ttl));\n        this._subRefreshTimeouts[channel] = subRefreshTimeout;\n      }\n      return;\n    }\n  }, {\n    key: '_subscribe',\n    value: function _subscribe(sub, isResubscribe) {\n      var _this16 = this;\n\n      this._debug('subscribing on', sub.channel);\n      var channel = sub.channel;\n\n      if (!(channel in this._subs)) {\n        this._subs[channel] = sub;\n      }\n\n      if (!this.isConnected()) {\n        // subscribe will be called later\n        sub._setNew();\n        return;\n      }\n\n      sub._setSubscribing(isResubscribe);\n\n      var msg = {\n        method: this._methodType.SUBSCRIBE,\n        params: {\n          channel: channel\n        }\n      };\n\n      // If channel name does not start with privateChannelPrefix - then we\n      // can just send subscription message to Centrifuge. If channel name\n      // starts with privateChannelPrefix - then this is a private channel\n      // and we should ask web application backend for permission first.\n      if ((0, _utils.startsWith)(channel, this._config.privateChannelPrefix)) {\n        // private channel.\n        if (this._isSubscribeBatching) {\n          this._privateChannels[channel] = true;\n        } else {\n          this.startSubscribeBatching();\n          this._subscribe(sub);\n          this.stopSubscribeBatching();\n        }\n      } else {\n        var recover = sub._needRecover();\n\n        if (recover === true) {\n          msg.params.recover = true;\n          var seq = this._getLastSeq(channel);\n          var gen = this._getLastGen(channel);\n          if (seq || gen) {\n            if (seq) {\n              msg.params.seq = seq;\n            }\n            if (gen) {\n              msg.params.gen = gen;\n            }\n          } else {\n            var offset = this._getLastOffset(channel);\n            if (offset) {\n              msg.params.offset = offset;\n            }\n          }\n          var epoch = this._getLastEpoch(channel);\n          if (epoch) {\n            msg.params.epoch = epoch;\n          }\n        }\n\n        this._call(msg).then(function (resolveCtx) {\n          _this16._subscribeResponse(channel, recover, _this16._decoder.decodeCommandResult(_this16._methodType.SUBSCRIBE, resolveCtx.result));\n          if (resolveCtx.next) {\n            resolveCtx.next();\n          }\n        }, function (rejectCtx) {\n          _this16._subscribeError(channel, rejectCtx.error);\n          if (rejectCtx.next) {\n            rejectCtx.next();\n          }\n        });\n      }\n    }\n  }, {\n    key: '_unsubscribe',\n    value: function _unsubscribe(sub) {\n      delete this._subs[sub.channel];\n      delete this._lastOffset[sub.channel];\n      delete this._lastSeq[sub.channel];\n      delete this._lastGen[sub.channel];\n      if (this.isConnected()) {\n        // No need to unsubscribe in disconnected state - i.e. client already unsubscribed.\n        this._addMessage({\n          method: this._methodType.UNSUBSCRIBE,\n          params: {\n            channel: sub.channel\n          }\n        });\n      }\n    }\n  }, {\n    key: '_getTTLMilliseconds',\n    value: function _getTTLMilliseconds(ttl) {\n      // https://stackoverflow.com/questions/12633405/what-is-the-maximum-delay-for-setinterval\n      return Math.min(ttl * 1000, 2147483647);\n    }\n  }, {\n    key: 'getSub',\n    value: function getSub(channel) {\n      return this._getSub(channel);\n    }\n  }, {\n    key: '_getSub',\n    value: function _getSub(channel) {\n      var sub = this._subs[channel];\n      if (!sub) {\n        return null;\n      }\n      return sub;\n    }\n  }, {\n    key: '_isServerSub',\n    value: function _isServerSub(channel) {\n      return this._serverSubs[channel] !== undefined;\n    }\n  }, {\n    key: '_connectResponse',\n    value: function _connectResponse(result, isRecover) {\n      var _this17 = this;\n\n      var wasReconnecting = this._reconnecting;\n      this._reconnecting = false;\n      this._resetRetry();\n      this._refreshRequired = false;\n\n      if (this.isConnected()) {\n        return;\n      }\n\n      if (this._latencyStart !== null) {\n        this._latency = new Date().getTime() - this._latencyStart.getTime();\n        this._latencyStart = null;\n      }\n\n      this._clientID = result.client;\n      this._setStatus('connected');\n\n      if (this._refreshTimeout) {\n        clearTimeout(this._refreshTimeout);\n      }\n\n      if (result.expires) {\n        this._refreshTimeout = setTimeout(function () {\n          return _this17._refresh();\n        }, this._getTTLMilliseconds(result.ttl));\n      }\n\n      this.startBatching();\n      this.startSubscribeBatching();\n      for (var channel in this._subs) {\n        if (this._subs.hasOwnProperty(channel)) {\n          var sub = this._subs[channel];\n          if (sub._shouldResubscribe()) {\n            this._subscribe(sub, wasReconnecting);\n          }\n        }\n      }\n      this.stopSubscribeBatching();\n      this.stopBatching();\n\n      this._startPing();\n\n      var ctx = {\n        client: result.client,\n        transport: this._transportName,\n        latency: this._latency\n      };\n      if (result.data) {\n        ctx.data = result.data;\n      }\n\n      this.emit('connect', ctx);\n\n      if (result.subs) {\n        this._processServerSubs(result.subs, isRecover);\n      }\n    }\n  }, {\n    key: '_processServerSubs',\n    value: function _processServerSubs(subs, isRecover) {\n      for (var channel in subs) {\n        if (subs.hasOwnProperty(channel)) {\n          var sub = subs[channel];\n          var isResubscribe = this._serverSubs[channel] !== undefined;\n          var subCtx = { channel: channel, isResubscribe: isResubscribe };\n          subCtx = this._expandSubscribeContext(subCtx, sub);\n          this.emit('subscribe', subCtx);\n        }\n      }\n      for (var _channel2 in subs) {\n        if (subs.hasOwnProperty(_channel2)) {\n          var _sub = subs[_channel2];\n          if (_sub.recovered) {\n            var pubs = _sub.publications;\n            if (pubs && pubs.length > 0) {\n\n              // handle legacy order.\n              // TODO: remove as soon as Centrifuge v1 released.\n              if (pubs.length > 1 && (!pubs[0].offset || pubs[0].offset > pubs[1].offset)) {\n                pubs = pubs.reverse();\n              }\n\n              for (var i in pubs) {\n                if (pubs.hasOwnProperty(i)) {\n                  this._handlePublication(_channel2, pubs[i]);\n                }\n              }\n            }\n          }\n          this._serverSubs[_channel2] = {\n            'seq': _sub.seq,\n            'gen': _sub.gen,\n            'offset': _sub.offset,\n            'epoch': _sub.epoch,\n            'recoverable': _sub.recoverable\n          };\n        }\n      }\n    }\n  }, {\n    key: '_stopPing',\n    value: function _stopPing() {\n      if (this._pongTimeout !== null) {\n        clearTimeout(this._pongTimeout);\n        this._pongTimeout = null;\n      }\n      if (this._pingTimeout !== null) {\n        clearTimeout(this._pingTimeout);\n        this._pingTimeout = null;\n      }\n    }\n  }, {\n    key: '_startPing',\n    value: function _startPing() {\n      var _this18 = this;\n\n      if (this._config.ping !== true || this._config.pingInterval <= 0) {\n        return;\n      }\n      if (!this.isConnected()) {\n        return;\n      }\n\n      this._pingTimeout = setTimeout(function () {\n        if (!_this18.isConnected()) {\n          _this18._stopPing();\n          return;\n        }\n        _this18.ping();\n        _this18._pongTimeout = setTimeout(function () {\n          _this18._disconnect('no ping', true);\n        }, _this18._config.pongWaitTimeout);\n      }, this._config.pingInterval);\n    }\n  }, {\n    key: '_restartPing',\n    value: function _restartPing() {\n      this._stopPing();\n      this._startPing();\n    }\n  }, {\n    key: '_subscribeError',\n    value: function _subscribeError(channel, error) {\n      var sub = this._getSub(channel);\n      if (!sub) {\n        return;\n      }\n      if (!sub._isSubscribing()) {\n        return;\n      }\n      if (error.code === 0 && error.message === _errorTimeout) {\n        // client side timeout.\n        this._disconnect('timeout', true);\n        return;\n      }\n      sub._setSubscribeError(error);\n    }\n  }, {\n    key: '_expandSubscribeContext',\n    value: function _expandSubscribeContext(ctx, result) {\n      var recovered = false;\n      if ('recovered' in result) {\n        recovered = result.recovered;\n      }\n      ctx.recovered = recovered;\n\n      var positioned = false;\n      if ('positioned' in result) {\n        positioned = result.positioned;\n      }\n      var epoch = '';\n      if ('epoch' in result) {\n        epoch = result.epoch;\n      }\n      var offset = 0;\n      if ('offset' in result) {\n        offset = result.offset;\n      }\n      if (positioned) {\n        ctx.streamPosition = {\n          'offset': offset,\n          'epoch': epoch\n        };\n      };\n      return ctx;\n    }\n  }, {\n    key: '_subscribeResponse',\n    value: function _subscribeResponse(channel, isRecover, result) {\n      var _this19 = this;\n\n      var sub = this._getSub(channel);\n      if (!sub) {\n        return;\n      }\n      if (!sub._isSubscribing()) {\n        return;\n      }\n      sub._setSubscribeSuccess(result);\n\n      var pubs = result.publications;\n      if (pubs && pubs.length > 0) {\n        if (pubs.length >= 2 && !pubs[0].offset && !pubs[1].offset) {\n          // handle legacy order.\n          pubs = pubs.reverse();\n        }\n        for (var i in pubs) {\n          if (pubs.hasOwnProperty(i)) {\n            this._handlePublication(channel, pubs[i]);\n          }\n        }\n      }\n\n      if (result.recoverable && (!isRecover || !result.recovered)) {\n        this._lastSeq[channel] = result.seq || 0;\n        this._lastGen[channel] = result.gen || 0;\n        this._lastOffset[channel] = result.offset || 0;\n      }\n\n      this._lastEpoch[channel] = result.epoch || '';\n\n      if (result.recoverable) {\n        sub._recoverable = true;\n      }\n\n      if (result.expires === true) {\n        var subRefreshTimeout = setTimeout(function () {\n          return _this19._subRefresh(channel);\n        }, this._getTTLMilliseconds(result.ttl));\n        this._subRefreshTimeouts[channel] = subRefreshTimeout;\n      }\n    }\n  }, {\n    key: '_handleReply',\n    value: function _handleReply(reply, next) {\n      var id = reply.id;\n      var result = reply.result;\n\n      if (!(id in this._callbacks)) {\n        next();\n        return;\n      }\n      var callbacks = this._callbacks[id];\n      clearTimeout(this._callbacks[id].timeout);\n      delete this._callbacks[id];\n\n      if (!(0, _utils.errorExists)(reply)) {\n        var callback = callbacks.callback;\n        if (!callback) {\n          return;\n        }\n        callback({ result: result, next: next });\n      } else {\n        var errback = callbacks.errback;\n        if (!errback) {\n          next();\n          return;\n        }\n        var error = reply.error;\n        errback({ error: error, next: next });\n      }\n    }\n  }, {\n    key: '_handleJoin',\n    value: function _handleJoin(channel, join) {\n      var ctx = { 'info': join.info };\n      var sub = this._getSub(channel);\n      if (!sub) {\n        if (this._isServerSub(channel)) {\n          ctx.channel = channel;\n          this.emit('join', ctx);\n        }\n        return;\n      }\n      sub.emit('join', ctx);\n    }\n  }, {\n    key: '_handleLeave',\n    value: function _handleLeave(channel, leave) {\n      var ctx = { 'info': leave.info };\n      var sub = this._getSub(channel);\n      if (!sub) {\n        if (this._isServerSub(channel)) {\n          ctx.channel = channel;\n          this.emit('leave', ctx);\n        }\n        return;\n      }\n      sub.emit('leave', ctx);\n    }\n  }, {\n    key: '_handleUnsub',\n    value: function _handleUnsub(channel, unsub) {\n      var ctx = {};\n      var sub = this._getSub(channel);\n      if (!sub) {\n        if (this._isServerSub(channel)) {\n          delete this._serverSubs[channel];\n          ctx.channel = channel;\n          this.emit('unsubscribe', ctx);\n        }\n        return;\n      }\n      sub.unsubscribe();\n      if (unsub.resubscribe === true) {\n        sub.subscribe();\n      }\n    }\n  }, {\n    key: '_handleSub',\n    value: function _handleSub(channel, sub) {\n      this._serverSubs[channel] = {\n        'seq': sub.seq,\n        'gen': sub.gen,\n        'offset': sub.offset,\n        'epoch': sub.epoch,\n        'recoverable': sub.recoverable\n      };\n      var ctx = { 'channel': channel, isResubscribe: false };\n      ctx = this._expandSubscribeContext(ctx, sub);\n      this.emit('subscribe', ctx);\n    }\n  }, {\n    key: '_handlePublication',\n    value: function _handlePublication(channel, pub) {\n      var sub = this._getSub(channel);\n      var ctx = {\n        'data': pub.data,\n        'seq': pub.seq,\n        'gen': pub.gen,\n        'offset': pub.offset\n      };\n      if (pub.info) {\n        ctx.info = pub.info;\n      }\n      if (!sub) {\n        if (this._isServerSub(channel)) {\n          if (pub.seq !== undefined) {\n            this._serverSubs[channel].seq = pub.seq;\n          }\n          if (pub.gen !== undefined) {\n            this._serverSubs[channel].gen = pub.gen;\n          }\n          if (pub.offset !== undefined) {\n            this._serverSubs[channel].offset = pub.offset;\n          }\n          ctx.channel = channel;\n          this.emit('publish', ctx);\n        }\n        return;\n      }\n      if (pub.seq !== undefined) {\n        this._lastSeq[channel] = pub.seq;\n      }\n      if (pub.gen !== undefined) {\n        this._lastGen[channel] = pub.gen;\n      }\n      if (pub.offset !== undefined) {\n        this._lastOffset[channel] = pub.offset;\n      }\n      sub.emit('publish', ctx);\n    }\n  }, {\n    key: '_handleMessage',\n    value: function _handleMessage(message) {\n      this.emit('message', message.data);\n    }\n  }, {\n    key: '_handlePush',\n    value: function _handlePush(data, next) {\n      var push = this._decoder.decodePush(data);\n      var type = 0;\n      if ('type' in push) {\n        type = push['type'];\n      }\n      var channel = push.channel;\n\n      if (type === this._pushType.PUBLICATION) {\n        var pub = this._decoder.decodePushData(this._pushType.PUBLICATION, push.data);\n        this._handlePublication(channel, pub);\n      } else if (type === this._pushType.MESSAGE) {\n        var message = this._decoder.decodePushData(this._pushType.MESSAGE, push.data);\n        this._handleMessage(message);\n      } else if (type === this._pushType.JOIN) {\n        var join = this._decoder.decodePushData(this._pushType.JOIN, push.data);\n        this._handleJoin(channel, join);\n      } else if (type === this._pushType.LEAVE) {\n        var leave = this._decoder.decodePushData(this._pushType.LEAVE, push.data);\n        this._handleLeave(channel, leave);\n      } else if (type === this._pushType.UNSUB) {\n        var unsub = this._decoder.decodePushData(this._pushType.UNSUB, push.data);\n        this._handleUnsub(channel, unsub);\n      } else if (type === this._pushType.SUB) {\n        var sub = this._decoder.decodePushData(this._pushType.SUB, push.data);\n        this._handleSub(channel, sub);\n      }\n      next();\n    }\n  }, {\n    key: '_flush',\n    value: function _flush() {\n      var messages = this._messages.slice(0);\n      this._messages = [];\n      this._transportSend(messages);\n    }\n  }, {\n    key: '_ping',\n    value: function _ping() {\n      var _this20 = this;\n\n      var msg = {\n        method: this._methodType.PING\n      };\n      this._call(msg).then(function (resolveCtx) {\n        _this20._pingResponse(_this20._decoder.decodeCommandResult(_this20._methodType.PING, resolveCtx.result));\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, function (rejectCtx) {\n        _this20._debug('ping error', rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    }\n  }, {\n    key: '_pingResponse',\n    value: function _pingResponse(result) {\n      if (!this.isConnected()) {\n        return;\n      }\n      this._stopPing();\n      this._startPing();\n    }\n  }, {\n    key: '_getLastSeq',\n    value: function _getLastSeq(channel) {\n      var lastSeq = this._lastSeq[channel];\n      if (lastSeq) {\n        return lastSeq;\n      }\n      return 0;\n    }\n  }, {\n    key: '_getLastOffset',\n    value: function _getLastOffset(channel) {\n      var lastOffset = this._lastOffset[channel];\n      if (lastOffset) {\n        return lastOffset;\n      }\n      return 0;\n    }\n  }, {\n    key: '_getLastGen',\n    value: function _getLastGen(channel) {\n      var lastGen = this._lastGen[channel];\n      if (lastGen) {\n        return lastGen;\n      }\n      return 0;\n    }\n  }, {\n    key: '_getLastEpoch',\n    value: function _getLastEpoch(channel) {\n      var lastEpoch = this._lastEpoch[channel];\n      if (lastEpoch) {\n        return lastEpoch;\n      }\n      return '';\n    }\n  }, {\n    key: '_createErrorObject',\n    value: function _createErrorObject(message, code) {\n      var errObject = {\n        message: message,\n        code: code || 0\n      };\n\n      return errObject;\n    }\n  }, {\n    key: '_registerCall',\n    value: function _registerCall(id, callback, errback) {\n      var _this21 = this;\n\n      this._callbacks[id] = {\n        callback: callback,\n        errback: errback,\n        timeout: null\n      };\n      this._callbacks[id].timeout = setTimeout(function () {\n        delete _this21._callbacks[id];\n        if ((0, _utils.isFunction)(errback)) {\n          errback({ error: _this21._createErrorObject(_errorTimeout) });\n        }\n      }, this._config.timeout);\n    }\n  }, {\n    key: '_addMessage',\n    value: function _addMessage(message) {\n      var id = this._nextMessageId();\n      message.id = id;\n      if (this._isBatching === true) {\n        this._messages.push(message);\n      } else {\n        this._transportSend([message]);\n      }\n      return id;\n    }\n  }, {\n    key: 'isConnected',\n    value: function isConnected() {\n      return this._isConnected();\n    }\n  }, {\n    key: 'connect',\n    value: function connect() {\n      this._connect();\n    }\n  }, {\n    key: 'disconnect',\n    value: function disconnect() {\n      this._disconnect('client', false);\n    }\n  }, {\n    key: 'ping',\n    value: function ping() {\n      return this._ping();\n    }\n  }, {\n    key: 'startBatching',\n    value: function startBatching() {\n      // start collecting messages without sending them to Centrifuge until flush\n      // method called\n      this._isBatching = true;\n    }\n  }, {\n    key: 'stopBatching',\n    value: function stopBatching() {\n      this._isBatching = false;\n      this._flush();\n    }\n  }, {\n    key: 'startSubscribeBatching',\n    value: function startSubscribeBatching() {\n      // start collecting private channels to create bulk authentication\n      // request to subscribeEndpoint when stopSubscribeBatching will be called\n      this._isSubscribeBatching = true;\n    }\n  }, {\n    key: 'stopSubscribeBatching',\n    value: function stopSubscribeBatching() {\n      var _this22 = this;\n\n      // create request to subscribeEndpoint with collected private channels\n      // to ask if this client can subscribe on each channel\n      this._isSubscribeBatching = false;\n      var authChannels = this._privateChannels;\n      this._privateChannels = {};\n\n      var channels = [];\n\n      for (var channel in authChannels) {\n        if (authChannels.hasOwnProperty(channel)) {\n          var sub = this._getSub(channel);\n          if (!sub) {\n            continue;\n          }\n          channels.push(channel);\n        }\n      }\n\n      if (channels.length === 0) {\n        this._debug('no private channels found, no need to make request');\n        return;\n      }\n\n      var data = {\n        client: this._clientID,\n        channels: channels\n      };\n\n      var clientID = this._clientID;\n      var xhrID = this._newXHRID();\n\n      var cb = function cb(resp) {\n        if (xhrID in _this22._xhrs) {\n          delete _this22._xhrs[xhrID];\n        }\n        if (_this22._clientID !== clientID) {\n          return;\n        }\n        if (resp.error || resp.status !== 200) {\n          _this22._debug('authorization request failed');\n          for (var i in channels) {\n            if (channels.hasOwnProperty(i)) {\n              var _channel3 = channels[i];\n              _this22._subscribeError(_channel3, _this22._createErrorObject('authorization request failed'));\n            }\n          }\n          return;\n        }\n\n        var channelsData = {};\n        if (resp.data.channels) {\n          for (var _i in resp.data.channels) {\n            var channelData = resp.data.channels[_i];\n            if (!channelData.channel) {\n              continue;\n            }\n            channelsData[channelData.channel] = channelData.token;\n          }\n        }\n\n        // try to send all subscriptions in one request.\n        var batch = false;\n\n        if (!_this22._isBatching) {\n          _this22.startBatching();\n          batch = true;\n        }\n\n        for (var _i2 in channels) {\n          if (channels.hasOwnProperty(_i2)) {\n            var _ret2 = function () {\n              var channel = channels[_i2];\n              var token = channelsData[channel];\n\n              if (!token) {\n                // subscription:error\n                _this22._subscribeError(channel, _this22._createErrorObject('permission denied', 103));\n                return 'continue';\n              } else {\n                var msg = {\n                  method: _this22._methodType.SUBSCRIBE,\n                  params: {\n                    channel: channel,\n                    token: token\n                  }\n                };\n\n                var _sub2 = _this22._getSub(channel);\n                if (_sub2 === null) {\n                  return 'continue';\n                }\n\n                var recover = _sub2._needRecover();\n\n                if (recover === true) {\n                  msg.params.recover = true;\n                  var seq = _this22._getLastSeq(channel);\n                  var gen = _this22._getLastGen(channel);\n                  if (seq || gen) {\n                    if (seq) {\n                      msg.params.seq = seq;\n                    }\n                    if (gen) {\n                      msg.params.gen = gen;\n                    }\n                  } else {\n                    var offset = _this22._getLastOffset(channel);\n                    if (offset) {\n                      msg.params.offset = offset;\n                    }\n                  }\n                  var epoch = _this22._getLastEpoch(channel);\n                  if (epoch) {\n                    msg.params.epoch = epoch;\n                  }\n                }\n                _this22._call(msg).then(function (resolveCtx) {\n                  _this22._subscribeResponse(channel, recover, _this22._decoder.decodeCommandResult(_this22._methodType.SUBSCRIBE, resolveCtx.result));\n                  if (resolveCtx.next) {\n                    resolveCtx.next();\n                  }\n                }, function (rejectCtx) {\n                  _this22._subscribeError(channel, rejectCtx.error);\n                  if (rejectCtx.next) {\n                    rejectCtx.next();\n                  }\n                });\n              }\n            }();\n\n            if (_ret2 === 'continue') continue;\n          }\n        }\n\n        if (batch) {\n          _this22.stopBatching();\n        }\n      };\n\n      if (this._config.onPrivateSubscribe !== null) {\n        this._config.onPrivateSubscribe({\n          data: data\n        }, cb);\n      } else {\n        var xhr = this._ajax(this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n        this._xhrs[xhrID] = xhr;\n      }\n    }\n  }, {\n    key: 'subscribe',\n    value: function subscribe(channel, events) {\n      var currentSub = this._getSub(channel);\n      if (currentSub !== null) {\n        currentSub._setEvents(events);\n        if (currentSub._isUnsubscribed()) {\n          currentSub.subscribe();\n        }\n        return currentSub;\n      }\n      var sub = new _subscription2.default(this, channel, events);\n      this._subs[channel] = sub;\n      sub.subscribe();\n      return sub;\n    }\n  }]);\n\n  return Centrifuge;\n}(_events2.default);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ }),\n\n/***/ 11:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(6);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _utils = __webpack_require__(7);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _STATE_NEW = 0;\nvar _STATE_SUBSCRIBING = 1;\nvar _STATE_SUCCESS = 2;\nvar _STATE_ERROR = 3;\nvar _STATE_UNSUBSCRIBED = 4;\n\nvar Subscription = function (_EventEmitter) {\n  _inherits(Subscription, _EventEmitter);\n\n  function Subscription(centrifuge, channel, events) {\n    _classCallCheck(this, Subscription);\n\n    var _this = _possibleConstructorReturn(this, (Subscription.__proto__ || Object.getPrototypeOf(Subscription)).call(this));\n\n    _this.channel = channel;\n    _this._centrifuge = centrifuge;\n    _this._status = _STATE_NEW;\n    _this._error = null;\n    _this._isResubscribe = false;\n    _this._ready = false;\n    _this._subscriptionPromise = null;\n    _this._noResubscribe = false;\n    _this._recoverable = false;\n    _this._recover = false;\n    _this._setEvents(events);\n    _this._initializePromise();\n    _this._promises = {};\n    _this._promiseId = 0;\n    _this.on('error', function (errContext) {\n      this._centrifuge._debug('subscription error', errContext);\n    });\n    return _this;\n  }\n\n  _createClass(Subscription, [{\n    key: '_nextPromiseId',\n    value: function _nextPromiseId() {\n      return ++this._promiseId;\n    }\n  }, {\n    key: '_initializePromise',\n    value: function _initializePromise() {\n      var _this2 = this;\n\n      // this helps us to wait until subscription will successfully\n      // subscribe and call actions such as presence, history etc in\n      // synchronous way.\n      this._ready = false;\n\n      this._subscriptionPromise = new Promise(function (resolve, reject) {\n        _this2._resolve = function (value) {\n          _this2._ready = true;\n          resolve(value);\n        };\n        _this2._reject = function (err) {\n          _this2._ready = true;\n          reject(err);\n        };\n      }).then(function () {}, function () {});\n    }\n  }, {\n    key: '_needRecover',\n    value: function _needRecover() {\n      return this._recoverable === true && this._recover === true;\n    }\n  }, {\n    key: '_setEvents',\n    value: function _setEvents(events) {\n      if (!events) {\n        return;\n      }\n      if ((0, _utils.isFunction)(events)) {\n        // events is just a function to handle publication received from channel.\n        this.on('publish', events);\n      } else if (Object.prototype.toString.call(events) === Object.prototype.toString.call({})) {\n        var knownEvents = ['publish', 'join', 'leave', 'unsubscribe', 'subscribe', 'error'];\n        for (var i = 0, l = knownEvents.length; i < l; i++) {\n          var ev = knownEvents[i];\n          if (ev in events) {\n            this.on(ev, events[ev]);\n          }\n        }\n      }\n    }\n  }, {\n    key: '_isNew',\n    value: function _isNew() {\n      return this._status === _STATE_NEW;\n    }\n  }, {\n    key: '_isUnsubscribed',\n    value: function _isUnsubscribed() {\n      return this._status === _STATE_UNSUBSCRIBED;\n    }\n  }, {\n    key: '_isSubscribing',\n    value: function _isSubscribing() {\n      return this._status === _STATE_SUBSCRIBING;\n    }\n  }, {\n    key: '_isReady',\n    value: function _isReady() {\n      return this._status === _STATE_SUCCESS || this._status === _STATE_ERROR;\n    }\n  }, {\n    key: '_isSuccess',\n    value: function _isSuccess() {\n      return this._status === _STATE_SUCCESS;\n    }\n  }, {\n    key: '_isError',\n    value: function _isError() {\n      return this._status === _STATE_ERROR;\n    }\n  }, {\n    key: '_setNew',\n    value: function _setNew() {\n      this._status = _STATE_NEW;\n    }\n  }, {\n    key: '_setSubscribing',\n    value: function _setSubscribing(isResubscribe) {\n      this._isResubscribe = isResubscribe || false;\n      if (this._ready === true) {\n        // new promise for this subscription\n        this._initializePromise();\n      }\n      this._status = _STATE_SUBSCRIBING;\n    }\n  }, {\n    key: '_setSubscribeSuccess',\n    value: function _setSubscribeSuccess(subCtx) {\n      if (this._status === _STATE_SUCCESS) {\n        return;\n      }\n      this._status = _STATE_SUCCESS;\n      var successContext = subCtx;\n      this._recover = false;\n      this.emit('subscribe', successContext);\n      this._resolve(successContext);\n      for (var id in this._promises) {\n        clearTimeout(this._promises[id].timeout);\n        this._promises[id].resolve();\n        delete this._promises[id];\n      }\n    }\n  }, {\n    key: '_setSubscribeError',\n    value: function _setSubscribeError(err) {\n      if (this._status === _STATE_ERROR) {\n        return;\n      }\n      this._status = _STATE_ERROR;\n      this._error = err;\n      var errContext = this._getSubscribeErrorContext();\n      this.emit('error', errContext);\n      this._reject(errContext);\n      for (var id in this._promises) {\n        clearTimeout(this._promises[id].timeout);\n        this._promises[id].reject(err);\n        delete this._promises[id];\n      }\n    }\n  }, {\n    key: '_triggerUnsubscribe',\n    value: function _triggerUnsubscribe() {\n      this.emit('unsubscribe', {\n        channel: this.channel\n      });\n    }\n  }, {\n    key: '_setUnsubscribed',\n    value: function _setUnsubscribed(noResubscribe) {\n      this._centrifuge._clearSubRefreshTimeout(this.channel);\n      if (this._status === _STATE_UNSUBSCRIBED) {\n        return;\n      }\n      var needTrigger = this._status === _STATE_SUCCESS;\n      this._status = _STATE_UNSUBSCRIBED;\n      if (noResubscribe === true) {\n        this._recover = false;\n        this._noResubscribe = true;\n        delete this._centrifuge._lastSeq[this.channel];\n        delete this._centrifuge._lastGen[this.channel];\n        delete this._centrifuge._lastEpoch[this.channel];\n      }\n      if (needTrigger) {\n        this._triggerUnsubscribe();\n      }\n    }\n  }, {\n    key: '_shouldResubscribe',\n    value: function _shouldResubscribe() {\n      return !this._noResubscribe;\n    }\n  }, {\n    key: '_getSubscribeSuccessContext',\n    value: function _getSubscribeSuccessContext(subscribeResult) {\n      var ctx = {\n        channel: this.channel,\n        isResubscribe: this._isResubscribe\n      };\n      ctx = this._centrifuge._expandSubscribeContext(ctx, subscribeResult);\n      return ctx;\n    }\n  }, {\n    key: '_getSubscribeErrorContext',\n    value: function _getSubscribeErrorContext() {\n      var subscribeErrorContext = this._error;\n      subscribeErrorContext.channel = this.channel;\n      subscribeErrorContext.isResubscribe = this._isResubscribe;\n      return subscribeErrorContext;\n    }\n  }, {\n    key: 'ready',\n    value: function ready(callback, errback) {\n      if (this._ready) {\n        if (this._isSuccess()) {\n          callback(this._getSubscribeSuccessContext());\n        } else {\n          errback(this._getSubscribeErrorContext());\n        }\n      }\n    }\n  }, {\n    key: 'subscribe',\n    value: function subscribe() {\n      if (this._status === _STATE_SUCCESS) {\n        return;\n      }\n      this._noResubscribe = false;\n      this._centrifuge._subscribe(this);\n    }\n  }, {\n    key: 'unsubscribe',\n    value: function unsubscribe() {\n      this._setUnsubscribed(true);\n      this._centrifuge._unsubscribe(this);\n    }\n  }, {\n    key: '_methodCall',\n    value: function _methodCall(message, type) {\n      var _this3 = this;\n\n      var methodCallPromise = new Promise(function (resolve, reject) {\n        var subPromise = void 0;\n        if (_this3._isSuccess()) {\n          subPromise = Promise.resolve();\n        } else if (_this3._isError()) {\n          subPromise = Promise.reject(_this3._error);\n        } else {\n          subPromise = new Promise(function (res, rej) {\n            var timeout = setTimeout(function () {\n              rej({ 'code': 0, 'message': 'timeout' });\n            }, _this3._centrifuge._config.timeout);\n            _this3._promises[_this3._nextPromiseId()] = {\n              timeout: timeout,\n              resolve: res,\n              reject: rej\n            };\n          });\n        }\n        subPromise.then(function () {\n          return _this3._centrifuge._call(message).then(function (resolveCtx) {\n            resolve(_this3._centrifuge._decoder.decodeCommandResult(type, resolveCtx.result));\n            if (resolveCtx.next) {\n              resolveCtx.next();\n            }\n          }, function (rejectCtx) {\n            reject(rejectCtx.error);\n            if (rejectCtx.next) {\n              rejectCtx.next();\n            }\n          });\n        }, function (error) {\n          reject(error);\n        });\n      });\n      return methodCallPromise;\n    }\n  }, {\n    key: 'publish',\n    value: function publish(data) {\n      return this._methodCall({\n        method: this._centrifuge._methodType.PUBLISH,\n        params: {\n          channel: this.channel,\n          data: data\n        }\n      }, this._centrifuge._methodType.PUBLISH);\n    }\n  }, {\n    key: 'presence',\n    value: function presence() {\n      return this._methodCall({\n        method: this._centrifuge._methodType.PRESENCE,\n        params: {\n          channel: this.channel\n        }\n      }, this._centrifuge._methodType.PRESENCE);\n    }\n  }, {\n    key: 'presenceStats',\n    value: function presenceStats() {\n      return this._methodCall({\n        method: this._centrifuge._methodType.PRESENCE_STATS,\n        params: {\n          channel: this.channel\n        }\n      }, this._centrifuge._methodType.PRESENCE_STATS);\n    }\n  }, {\n    key: 'history',\n    value: function history(options) {\n      var params = this._centrifuge._getHistoryParams(this.channel, options);\n      return this._methodCall({\n        method: this._centrifuge._methodType.HISTORY,\n        params: params\n      }, this._centrifuge._methodType.HISTORY);\n    }\n  }]);\n\n  return Subscription;\n}(_events2.default);\n\nexports.default = Subscription;\nmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 12:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JsonMethodType = exports.JsonMethodType = {\n  CONNECT: 0,\n  SUBSCRIBE: 1,\n  UNSUBSCRIBE: 2,\n  PUBLISH: 3,\n  PRESENCE: 4,\n  PRESENCE_STATS: 5,\n  HISTORY: 6,\n  PING: 7,\n  SEND: 8,\n  RPC: 9,\n  REFRESH: 10,\n  SUB_REFRESH: 11\n};\n\nvar JsonPushType = exports.JsonPushType = {\n  PUBLICATION: 0,\n  JOIN: 1,\n  LEAVE: 2,\n  UNSUB: 3,\n  MESSAGE: 4,\n  SUB: 5\n};\n\nvar JsonEncoder = exports.JsonEncoder = function () {\n  function JsonEncoder() {\n    _classCallCheck(this, JsonEncoder);\n  }\n\n  _createClass(JsonEncoder, [{\n    key: 'encodeCommands',\n    value: function encodeCommands(commands) {\n      var encodedCommands = [];\n      for (var i in commands) {\n        if (commands.hasOwnProperty(i)) {\n          encodedCommands.push(JSON.stringify(commands[i]));\n        }\n      }\n      return encodedCommands.join('\\n');\n    }\n  }]);\n\n  return JsonEncoder;\n}();\n\nvar JsonDecoder = exports.JsonDecoder = function () {\n  function JsonDecoder() {\n    _classCallCheck(this, JsonDecoder);\n  }\n\n  _createClass(JsonDecoder, [{\n    key: 'decodeReplies',\n    value: function decodeReplies(data) {\n      var replies = [];\n      var encodedReplies = data.split('\\n');\n      for (var i in encodedReplies) {\n        if (encodedReplies.hasOwnProperty(i)) {\n          if (!encodedReplies[i]) {\n            continue;\n          }\n          var reply = JSON.parse(encodedReplies[i]);\n          replies.push(reply);\n        }\n      }\n      return replies;\n    }\n  }, {\n    key: 'decodeCommandResult',\n    value: function decodeCommandResult(methodType, data) {\n      return data;\n    }\n  }, {\n    key: 'decodePush',\n    value: function decodePush(data) {\n      return data;\n    }\n  }, {\n    key: 'decodePushData',\n    value: function decodePushData(pushType, data) {\n      return data;\n    }\n  }]);\n\n  return JsonDecoder;\n}();\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n\n/***/ 31:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _centrifuge = __webpack_require__(10);\n\nexports.default = _centrifuge.Centrifuge;\nmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 6:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n/***/ }),\n\n/***/ 7:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.startsWith = startsWith;\nexports.isFunction = isFunction;\nexports.log = log;\nexports.backoff = backoff;\nexports.errorExists = errorExists;\nexports.extend = extend;\nfunction startsWith(value, prefix) {\n  return value.lastIndexOf(prefix, 0) === 0;\n};\n\nfunction isFunction(value) {\n  if (value === undefined || value === null) {\n    return false;\n  }\n  return typeof value === 'function';\n};\n\nfunction log(level, args) {\n  if (global.console) {\n    var logger = global.console[level];\n\n    if (isFunction(logger)) {\n      logger.apply(global.console, args);\n    }\n  }\n};\n\nfunction backoff(step, min, max) {\n  var jitter = 0.5 * Math.random();\n  var interval = Math.min(max, min * Math.pow(2, step + 1));\n\n  return Math.floor((1 - jitter) * interval);\n};\n\nfunction errorExists(data) {\n  return 'error' in data && data.error !== null;\n};\n\nfunction extend(a, b) {\n  for (var key in b) {\n    if (b.hasOwnProperty(key)) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ })\n\n/******/ });\n});\n\n\n// WEBPACK FOOTER //\n// centrifuge.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 31);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap aad167f0d4f3961f30c4","import EventEmitter from 'events';\nimport Subscription from './subscription';\n\nimport {\n  JsonEncoder,\n  JsonDecoder,\n  JsonMethodType,\n  JsonPushType\n} from './json';\n\nimport {\n  isFunction,\n  log,\n  startsWith,\n  errorExists,\n  backoff,\n  extend\n} from './utils';\n\nconst _errorTimeout = 'timeout';\nconst _errorConnectionClosed = 'connection closed';\n\nexport class Centrifuge extends EventEmitter {\n\n  constructor(url, options) {\n    super();\n    this._url = url;\n    this._websocket = null;\n    this._sockjs = null;\n    this._isSockjs = false;\n    this._binary = false;\n    this._methodType = null;\n    this._pushType = null;\n    this._encoder = null;\n    this._decoder = null;\n    this._status = 'disconnected';\n    this._reconnect = true;\n    this._reconnecting = false;\n    this._transport = null;\n    this._transportName = null;\n    this._transportClosed = true;\n    this._messageId = 0;\n    this._clientID = null;\n    this._refreshRequired = false;\n    this._subs = {};\n    this._serverSubs = {};\n    this._lastSeq = {};\n    this._lastGen = {};\n    this._lastOffset = {};\n    this._lastEpoch = {};\n    this._messages = [];\n    this._isBatching = false;\n    this._isSubscribeBatching = false;\n    this._privateChannels = {};\n    this._numRefreshFailed = 0;\n    this._refreshTimeout = null;\n    this._pingTimeout = null;\n    this._pongTimeout = null;\n    this._subRefreshTimeouts = {};\n    this._retries = 0;\n    this._callbacks = {};\n    this._latency = null;\n    this._latencyStart = null;\n    this._connectData = null;\n    this._token = null;\n    this._xhrID = 0;\n    this._xhrs = {};\n    this._dispatchPromise = Promise.resolve();\n    this._config = {\n      debug: false,\n      websocket: null,\n      sockjs: null,\n      promise: null,\n      minRetry: 1000,\n      maxRetry: 20000,\n      timeout: 5000,\n      ping: true,\n      pingInterval: 25000,\n      pongWaitTimeout: 5000,\n      privateChannelPrefix: '$',\n      onTransportClose: null,\n      sockjsServer: null,\n      sockjsTransports: [\n        'websocket',\n        'xdr-streaming',\n        'xhr-streaming',\n        'eventsource',\n        'iframe-eventsource',\n        'iframe-htmlfile',\n        'xdr-polling',\n        'xhr-polling',\n        'iframe-xhr-polling',\n        'jsonp-polling'\n      ],\n      refreshEndpoint: '/centrifuge/refresh',\n      refreshHeaders: {},\n      refreshParams: {},\n      refreshData: {},\n      refreshAttempts: null,\n      refreshInterval: 1000,\n      onRefreshFailed: null,\n      onRefresh: null,\n      subscribeEndpoint: '/centrifuge/subscribe',\n      subscribeHeaders: {},\n      subscribeParams: {},\n      subRefreshInterval: 1000,\n      onPrivateSubscribe: null\n    };\n    this._configure(options);\n  }\n\n  setToken(token) {\n    this._token = token;\n  }\n\n  setConnectData(data) {\n    this._connectData = data;\n  }\n\n  setRefreshHeaders(headers) {\n    this._config.refreshHeaders = headers;\n  }\n  setRefreshParams(params) {\n    this._config.refreshParams = params;\n  }\n  setRefreshData(data) {\n    this._config.refreshData = data;\n  }\n\n  setSubscribeHeaders(headers) {\n    this._config.subscribeHeaders = headers;\n  }\n  setSubscribeParams(params) {\n    this._config.subscribeParams = params;\n  }\n\n  _ajax(url, params, headers, data, callback) {\n    let query = '';\n    this._debug('sending AJAX request to', url, 'with data', JSON.stringify(data));\n\n    const xhr = (global.XMLHttpRequest ? new global.XMLHttpRequest() : new global.ActiveXObject('Microsoft.XMLHTTP'));\n\n    for (const i in params) {\n      if (params.hasOwnProperty(i)) {\n        if (query.length > 0) {\n          query += '&';\n        }\n        query += encodeURIComponent(i) + '=' + encodeURIComponent(params[i]);\n      }\n    }\n    if (query.length > 0) {\n      query = '?' + query;\n    }\n    xhr.open('POST', url + query, true);\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = true;\n    }\n\n    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    for (const headerName in headers) {\n      if (headers.hasOwnProperty(headerName)) {\n        xhr.setRequestHeader(headerName, headers[headerName]);\n      }\n    }\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200) {\n          let data, parsed = false;\n          try {\n            data = JSON.parse(xhr.responseText);\n            parsed = true;\n          } catch (e) {\n            callback({\n              error: 'Invalid JSON. Data was: ' + xhr.responseText,\n              status: 200,\n              data: null\n            });\n          }\n          if (parsed) { // prevents double execution.\n            callback({\n              data: data,\n              status: 200\n            });\n          }\n        } else {\n          this._log('wrong status code in AJAX response', xhr.status);\n          callback({\n            status: xhr.status,\n            data: null\n          });\n        }\n      }\n    };\n    setTimeout(() => xhr.send(JSON.stringify(data)), 20);\n    return xhr;\n  };\n\n  _log() {\n    log('info', arguments);\n  };\n\n  _debug() {\n    if (this._config.debug === true) {\n      log('debug', arguments);\n    }\n  };\n\n  _websocketSupported() {\n    if (this._config.websocket !== null) {\n      return true;\n    }\n    return !(typeof WebSocket !== 'function' && typeof WebSocket !== 'object');\n  };\n\n  _setFormat(format) {\n    if (this._formatOverride(format)) {\n      return;\n    }\n    if (format === 'protobuf') {\n      throw new Error('not implemented by JSON only Centrifuge client – use client with Protobuf');\n    }\n    this._binary = false;\n    this._methodType = JsonMethodType;\n    this._pushType = JsonPushType;\n    this._encoder = new JsonEncoder();\n    this._decoder = new JsonDecoder();\n  }\n\n  _formatOverride(format) {\n    return false;\n  }\n\n  _configure(configuration) {\n    if (!('Promise' in global)) {\n      throw new Error('Promise polyfill required');\n    }\n\n    extend(this._config, configuration || {});\n    this._debug('centrifuge config', this._config);\n\n    if (!this._url) {\n      throw new Error('url required');\n    }\n\n    if (startsWith(this._url, 'ws') && this._url.indexOf('format=protobuf') > -1) {\n      this._setFormat('protobuf');\n    } else {\n      this._setFormat('json');\n    }\n\n    if (startsWith(this._url, 'http')) {\n      this._debug('client will try to connect to SockJS endpoint');\n      if (this._config.sockjs !== null) {\n        this._debug('SockJS explicitly provided in options');\n        this._sockjs = this._config.sockjs;\n      } else {\n        if (typeof global.SockJS === 'undefined') {\n          throw new Error('SockJS not found, use ws:// in url or include SockJS');\n        }\n        this._debug('use globally defined SockJS');\n        this._sockjs = global.SockJS;\n      }\n    } else {\n      this._debug('client will connect to websocket endpoint');\n    }\n  };\n\n  _setStatus(newStatus) {\n    if (this._status !== newStatus) {\n      this._debug('Status', this._status, '->', newStatus);\n      this._status = newStatus;\n    }\n  };\n\n  _isDisconnected() {\n    return this._status === 'disconnected';\n  };\n\n  _isConnecting() {\n    return this._status === 'connecting';\n  };\n\n  _isConnected() {\n    return this._status === 'connected';\n  };\n\n  _nextMessageId() {\n    return ++this._messageId;\n  };\n\n  _resetRetry() {\n    this._debug('reset retries count to 0');\n    this._retries = 0;\n  };\n\n  _getRetryInterval() {\n    const interval = backoff(this._retries, this._config.minRetry, this._config.maxRetry);\n\n    this._retries += 1;\n    return interval;\n  };\n\n  _abortInflightXHRs() {\n    for (const xhrID in this._xhrs) {\n      try {\n        this._xhrs[xhrID].abort();\n      } catch (e) {\n        this._debug('error aborting xhr', e);\n      }\n      delete this._xhrs[xhrID];\n    }\n  };\n\n  _clearConnectedState(reconnect) {\n    this._clientID = null;\n    this._stopPing();\n\n    // fire errbacks of registered outgoing calls.\n    for (const id in this._callbacks) {\n      if (this._callbacks.hasOwnProperty(id)) {\n        const callbacks = this._callbacks[id];\n        clearTimeout(callbacks.timeout);\n        const errback = callbacks.errback;\n        if (!errback) {\n          continue;\n        }\n        errback({error: this._createErrorObject('disconnected')});\n      }\n    }\n    this._callbacks = {};\n\n    // fire unsubscribe events\n    for (const channel in this._subs) {\n      if (this._subs.hasOwnProperty(channel)) {\n        const sub = this._subs[channel];\n\n        if (reconnect) {\n          if (sub._isSuccess()) {\n            sub._triggerUnsubscribe();\n            sub._recover = true;\n          }\n          if (sub._shouldResubscribe()) {\n            sub._setSubscribing();\n          }\n        } else {\n          sub._setUnsubscribed();\n        }\n      }\n    }\n\n    this._abortInflightXHRs();\n\n    // clear refresh timer\n    if (this._refreshTimeout !== null) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n\n    // clear sub refresh timers\n    for (const channel in this._subRefreshTimeouts) {\n      if (this._subRefreshTimeouts.hasOwnProperty(channel) && this._subRefreshTimeouts[channel]) {\n        this._clearSubRefreshTimeout(channel);\n      }\n    }\n    this._subRefreshTimeouts = {};\n\n    if (!this._reconnect) {\n      // completely clear subscriptions\n      this._subs = {};\n    }\n  };\n\n  _isTransportOpen() {\n    if (this._isSockjs) {\n      return this._transport &&\n        this._transport.transport &&\n        this._transport.transport.readyState === this._transport.transport.OPEN;\n    }\n    return this._transport && this._transport.readyState === this._transport.OPEN;\n  };\n\n  _transportSend(commands) {\n    if (!commands.length) {\n      return true;\n    }\n\n    if (!this._isTransportOpen()) {\n      // resolve pending commands with error if transport is not open\n      for (let command in commands) {\n        let id = command.id;\n        if (!(id in this._callbacks)) {\n          continue;\n        }\n        const callbacks = this._callbacks[id];\n        clearTimeout(this._callbacks[id].timeout);\n        delete this._callbacks[id];\n        const errback = callbacks.errback;\n        errback({error: this._createErrorObject(_errorConnectionClosed, 0)});\n      }\n      return false;\n    }\n    this._transport.send(this._encoder.encodeCommands(commands));\n    return true;\n  }\n\n  _setupTransport() {\n    this._isSockjs = false;\n\n    // detect transport to use - SockJS or Websocket\n    if (this._sockjs !== null) {\n      const sockjsOptions = {\n        transports: this._config.sockjsTransports\n      };\n\n      if (this._config.sockjsServer !== null) {\n        sockjsOptions.server = this._config.sockjsServer;\n      }\n      this._isSockjs = true;\n      this._transport = new this._sockjs(this._url, null, sockjsOptions);\n    } else {\n      if (!this._websocketSupported()) {\n        this._debug('No Websocket support and no SockJS configured, can not connect');\n        return;\n      }\n      if (this._config.websocket !== null) {\n        this._websocket = this._config.websocket;\n      } else {\n        this._websocket = WebSocket;\n      }\n      this._transport = new this._websocket(this._url);\n      if (this._binary === true) {\n        this._transport.binaryType = 'arraybuffer';\n      }\n    }\n\n    this._transport.onopen = () => {\n      this._transportClosed = false;\n\n      if (this._isSockjs) {\n        this._transportName = 'sockjs-' + this._transport.transport;\n        this._transport.onheartbeat = () => this._restartPing();\n      } else {\n        this._transportName = 'websocket';\n      }\n\n      // Can omit method here due to zero value.\n      const msg = {\n        // method: this._methodType.CONNECT\n      };\n\n      if (this._token || this._connectData) {\n        msg.params = {};\n      }\n\n      if (this._token) {\n        msg.params.token = this._token;\n      }\n\n      if (this._connectData) {\n        msg.params.data = this._connectData;\n      }\n\n      let subs = {};\n      let hasSubs = false;\n      for (const channel in this._serverSubs) {\n        if (this._serverSubs.hasOwnProperty(channel) && this._serverSubs[channel].recoverable) {\n          hasSubs = true;\n          let sub = {\n            'recover': true\n          };\n          if (this._serverSubs[channel].seq || this._serverSubs[channel].gen) {\n            if (this._serverSubs[channel].seq) {\n              sub['seq'] = this._serverSubs[channel].seq;\n            }\n            if (this._serverSubs[channel].gen) {\n              sub['gen'] = this._serverSubs[channel].gen;\n            }\n          } else {\n            if (this._serverSubs[channel].offset) {\n              sub['offset'] = this._serverSubs[channel].offset;\n            }\n          }\n          if (this._serverSubs[channel].epoch) {\n            sub['epoch'] = this._serverSubs[channel].epoch;\n          }\n          subs[channel] = sub;\n        }\n      }\n      if (hasSubs) {\n        if (!msg.params) {msg.params = {};}\n        msg.params.subs = subs;\n      }\n\n      this._latencyStart = new Date();\n      this._call(msg).then(resolveCtx => {\n        this._connectResponse(this._decoder.decodeCommandResult(this._methodType.CONNECT, resolveCtx.result), hasSubs);\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        const err = rejectCtx.error;\n        if (err.code === 109) { // token expired.\n          this._refreshRequired = true;\n        }\n        this._disconnect('connect error', true);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    };\n\n    this._transport.onerror = error => {\n      this._debug('transport level error', error);\n    };\n\n    this._transport.onclose = closeEvent => {\n      this._transportClosed = true;\n      let reason = _errorConnectionClosed;\n      let needReconnect = true;\n\n      if (closeEvent && 'reason' in closeEvent && closeEvent.reason) {\n        try {\n          const advice = JSON.parse(closeEvent.reason);\n          this._debug('reason is an advice object', advice);\n          reason = advice.reason;\n          needReconnect = advice.reconnect;\n        } catch (e) {\n          reason = closeEvent.reason;\n          this._debug('reason is a plain string', reason);\n        }\n      }\n\n      // onTransportClose callback should be executed every time transport was closed.\n      // This can be helpful to catch failed connection events (because our disconnect\n      // event only called once and every future attempts to connect do not fire disconnect\n      // event again).\n      if (this._config.onTransportClose !== null) {\n        this._config.onTransportClose({\n          event: closeEvent,\n          reason: reason,\n          reconnect: needReconnect\n        });\n      }\n\n      this._disconnect(reason, needReconnect);\n\n      if (this._reconnect === true) {\n        this._reconnecting = true;\n        const interval = this._getRetryInterval();\n\n        this._debug('reconnect after ' + interval + ' milliseconds');\n        setTimeout(() => {\n          if (this._reconnect === true) {\n            if (this._refreshRequired) {\n              this._refresh();\n            } else {\n              this._connect();\n            }\n          }\n        }, interval);\n      }\n    };\n\n    this._transport.onmessage = event => {\n      this._dataReceived(event.data);\n    };\n  };\n\n  rpc(data) {\n    return this._rpc('', data);\n  }\n\n  namedRPC(method, data) {\n    return this._rpc(method, data);\n  }\n\n  _rpc(method, data) {\n    let params = {\n      data: data\n    };\n    if (method !== '') {\n      params.method = method;\n    };\n    const msg = {\n      method: this._methodType.RPC,\n      params: params\n    };\n\n    if (!this.isConnected()) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    }\n\n    return this._call(msg).then(resolveCtx => {\n      if (resolveCtx.next) {\n        resolveCtx.next();\n      }\n      return this._decoder.decodeCommandResult(this._methodType.RPC, resolveCtx.result);\n    }, rejectCtx => {\n      if (rejectCtx.next) {\n        rejectCtx.next();\n      }\n      return Promise.reject(rejectCtx.error);\n    });\n  }\n\n  send(data) {\n    const msg = {\n      method: this._methodType.SEND,\n      params: {\n        data: data\n      }\n    };\n\n    if (!this.isConnected()) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    }\n\n    const sent = this._transportSend([msg]); // can send async message to server without id set\n    if (!sent) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    };\n    return Promise.resolve({});\n  }\n\n  _getHistoryParams(channel, options) {\n    let params = {\n      channel: channel\n    };\n    if (options !== undefined) {\n      if (options.since) {\n        params['use_since'] = true;\n        if (options.since.offset) {\n          params['offset'] = options.since.offset;\n        }\n        if (options.since.epoch) {\n          params['epoch'] = options.since.epoch;\n        }\n      };\n      if (options.limit !== undefined) {\n        params['use_limit'] = true;\n        params['limit'] = options.limit;\n      }\n    };\n    return params;\n  }\n\n  history(channel, options) {\n    const params = this._getHistoryParams(channel, options);\n    const msg = {\n      method: this._methodType.HISTORY,\n      params: params\n    };\n\n    if (!this.isConnected()) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._call(msg).then(resolveCtx => {\n        resolve(resolveCtx.result);\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        reject(rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    });\n  }\n\n  publish(channel, data) {\n    const msg = {\n      method: this._methodType.PUBLISH,\n      params: {\n        channel: channel,\n        data: data\n      }\n    };\n\n    if (!this.isConnected()) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._call(msg).then(resolveCtx => {\n        resolve({});\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        reject(rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    });\n  }\n\n  _dataReceived(data) {\n    const replies = this._decoder.decodeReplies(data);\n    // we have to guarantee order of events in replies processing - i.e. start processing\n    // next reply only when we finished processing of current one. Without syncing things in\n    // this way we could get wrong publication events order as reply promises resolve\n    // on next loop tick so for loop continues before we finished emitting all reply events.\n    this._dispatchPromise = this._dispatchPromise.then(() => {\n      let finishDispatch;\n      this._dispatchPromise = new Promise(resolve =>{\n        finishDispatch = resolve;\n      });\n      this._dispatchSynchronized(replies, finishDispatch);\n    });\n    this._restartPing();\n  }\n\n  _dispatchSynchronized(replies, finishDispatch) {\n    let p = Promise.resolve();\n    for (const i in replies) {\n      if (replies.hasOwnProperty(i)) {\n        p = p.then(() => {\n          return this._dispatchReply(replies[i]);\n        });\n      }\n    }\n    p = p.then(() => {\n      finishDispatch();\n    });\n  }\n\n  _dispatchReply(reply) {\n    var next;\n    const p = new Promise(resolve =>{\n      next = resolve;\n    });\n\n    if (reply === undefined || reply === null) {\n      this._debug('dispatch: got undefined or null reply');\n      next();\n      return p;\n    }\n\n    const id = reply.id;\n\n    if (id && id > 0) {\n      this._handleReply(reply, next);\n    } else {\n      this._handlePush(reply.result, next);\n    }\n\n    return p;\n  };\n\n  _call(msg) {\n    return new Promise((resolve, reject) => {\n      const id = this._addMessage(msg);\n      this._registerCall(id, resolve, reject);\n    });\n  }\n\n  _connect() {\n    if (this.isConnected()) {\n      this._debug('connect called when already connected');\n      return;\n    }\n    if (this._status === 'connecting') {\n      return;\n    }\n\n    this._debug('start connecting');\n    this._setStatus('connecting');\n    this._clientID = null;\n    this._reconnect = true;\n    this._setupTransport();\n  };\n\n  _disconnect(reason, shouldReconnect) {\n\n    const reconnect = shouldReconnect || false;\n    if (reconnect === false) {\n      this._reconnect = false;\n    }\n\n    if (this._isDisconnected()) {\n      if (!reconnect) {\n        this._clearConnectedState(reconnect);\n      }\n      return;\n    }\n\n    this._clearConnectedState(reconnect);\n\n    this._debug('disconnected:', reason, shouldReconnect);\n    this._setStatus('disconnected');\n\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    if (this._reconnecting === false) {\n      // fire unsubscribe events for server side subs.\n      for (const channel in this._serverSubs) {\n        if (this._serverSubs.hasOwnProperty(channel)) {\n          this.emit('unsubscribe', {channel: channel});\n        }\n      }\n      this.emit('disconnect', {\n        reason: reason,\n        reconnect: reconnect\n      });\n    }\n\n    if (reconnect === false) {\n      this._subs = {};\n      this._serverSubs = {};\n    }\n\n    if (!this._transportClosed) {\n      this._transport.close();\n    }\n  };\n\n  _refreshFailed() {\n    this._numRefreshFailed = 0;\n    if (!this._isDisconnected()) {\n      this._disconnect('refresh failed', false);\n    }\n    if (this._config.onRefreshFailed !== null) {\n      this._config.onRefreshFailed();\n    }\n  };\n\n  _refresh() {\n    // ask application for new connection token.\n    this._debug('refresh token');\n\n    if (this._config.refreshAttempts === 0) {\n      this._debug('refresh attempts set to 0, do not send refresh request at all');\n      this._refreshFailed();\n      return;\n    }\n\n    if (this._refreshTimeout !== null) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n\n    const clientID = this._clientID;\n    const xhrID = this._newXHRID();\n\n    const cb = (resp) => {\n      if (xhrID in this._xhrs) {\n        delete this._xhrs[xhrID];\n      }\n      if (this._clientID !== clientID) {\n        return;\n      }\n      if (resp.error || resp.status !== 200) {\n        // We don't perform any connection status related actions here as we are\n        // relying on server that must close connection eventually.\n        if (resp.error) {\n          this._debug('error refreshing connection token', resp.error);\n        } else {\n          this._debug('error refreshing connection token: wrong status code', resp.status);\n        }\n        this._numRefreshFailed++;\n        if (this._refreshTimeout !== null) {\n          clearTimeout(this._refreshTimeout);\n          this._refreshTimeout = null;\n        }\n        if (this._config.refreshAttempts !== null && this._numRefreshFailed >= this._config.refreshAttempts) {\n          this._refreshFailed();\n          return;\n        }\n        const jitter = Math.round(Math.random() * 1000 * Math.max(this._numRefreshFailed, 20));\n        const interval = this._config.refreshInterval + jitter;\n        this._refreshTimeout = setTimeout(() => this._refresh(), interval);\n        return;\n      }\n      this._numRefreshFailed = 0;\n      this._token = resp.data.token;\n      if (!this._token) {\n        this._refreshFailed();\n        return;\n      }\n      if (this._isDisconnected() && this._reconnect) {\n        this._debug('token refreshed, connect from scratch');\n        this._connect();\n      } else {\n        this._debug('send refreshed token');\n        const msg = {\n          method: this._methodType.REFRESH,\n          params: {\n            token: this._token\n          }\n        };\n        this._call(msg).then(resolveCtx => {\n          this._refreshResponse(this._decoder.decodeCommandResult(this._methodType.REFRESH, resolveCtx.result));\n          if (resolveCtx.next) {\n            resolveCtx.next();\n          }\n        }, rejectCtx => {\n          this._refreshError(rejectCtx.error);\n          if (rejectCtx.next) {\n            rejectCtx.next();\n          }\n        });\n      }\n    };\n\n    if (this._config.onRefresh !== null) {\n      const context = {};\n      this._config.onRefresh(context, cb);\n    } else {\n      const xhr = this._ajax(\n        this._config.refreshEndpoint,\n        this._config.refreshParams,\n        this._config.refreshHeaders,\n        this._config.refreshData,\n        cb\n      );\n      this._xhrs[xhrID] = xhr;\n    }\n  };\n\n  _refreshError(err) {\n    this._debug('refresh error', err);\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    const interval = this._config.refreshInterval + Math.round(Math.random() * 1000);\n    this._refreshTimeout = setTimeout(() => this._refresh(), interval);\n  }\n\n  _refreshResponse(result) {\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    if (result.expires) {\n      this._clientID = result.client;\n      this._refreshTimeout = setTimeout(() => this._refresh(), this._getTTLMilliseconds(result.ttl));\n    }\n  };\n\n  _newXHRID() {\n    this._xhrID++;\n    return this._xhrID;\n  }\n\n  _subRefresh(channel) {\n    this._debug('refresh subscription token for channel', channel);\n\n    if (this._subRefreshTimeouts[channel] !== undefined) {\n      this._clearSubRefreshTimeout(channel);\n    } else {\n      return;\n    }\n\n    const clientID = this._clientID;\n    const xhrID = this._newXHRID();\n\n    const cb = (resp) => {\n      if (xhrID in this._xhrs) {\n        delete this._xhrs[xhrID];\n      }\n      if (resp.error || resp.status !== 200 || this._clientID !== clientID) {\n        return;\n      }\n      let channelsData = {};\n      if (resp.data.channels) {\n        for (const i in resp.data.channels) {\n          const channelData = resp.data.channels[i];\n          if (!channelData.channel) {\n            continue;\n          }\n          channelsData[channelData.channel] = channelData.token;\n        }\n      }\n\n      const token = channelsData[channel];\n      if (!token) {\n        return;\n      }\n      const msg = {\n        method: this._methodType.SUB_REFRESH,\n        params: {\n          channel: channel,\n          token: token\n        }\n      };\n\n      const sub = this._getSub(channel);\n      if (sub === null) {\n        return;\n      }\n\n      this._call(msg).then(resolveCtx => {\n        this._subRefreshResponse(\n          channel,\n          this._decoder.decodeCommandResult(this._methodType.SUB_REFRESH, resolveCtx.result)\n        );\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        this._subRefreshError(channel, rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    };\n\n    const data = {\n      client: this._clientID,\n      channels: [channel]\n    };\n\n    if (this._config.onPrivateSubscribe !== null) {\n      this._config.onPrivateSubscribe({\n        data: data\n      }, cb);\n    } else {\n      const xhr = this._ajax(\n        this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n      this._xhrs[xhrID] = xhr;\n    }\n  };\n\n  _clearSubRefreshTimeout(channel) {\n    if (this._subRefreshTimeouts[channel] !== undefined) {\n      clearTimeout(this._subRefreshTimeouts[channel]);\n      delete this._subRefreshTimeouts[channel];\n    }\n  }\n\n  _subRefreshError(channel, err) {\n    this._debug('subscription refresh error', channel, err);\n    this._clearSubRefreshTimeout(channel);\n    const sub = this._getSub(channel);\n    if (sub === null) {\n      return;\n    }\n    const jitter = Math.round(Math.random() * 1000);\n    let subRefreshTimeout = setTimeout(() => this._subRefresh(channel), this._config.subRefreshInterval + jitter);\n    this._subRefreshTimeouts[channel] = subRefreshTimeout;\n    return;\n  }\n\n  _subRefreshResponse(channel, result) {\n    this._debug('subscription refresh success', channel);\n    this._clearSubRefreshTimeout(channel);\n    const sub = this._getSub(channel);\n    if (sub === null) {\n      return;\n    }\n    if (result.expires === true) {\n      let subRefreshTimeout = setTimeout(() => this._subRefresh(channel), this._getTTLMilliseconds(result.ttl));\n      this._subRefreshTimeouts[channel] = subRefreshTimeout;\n    }\n    return;\n  };\n\n  _subscribe(sub, isResubscribe) {\n    this._debug('subscribing on', sub.channel);\n    const channel = sub.channel;\n\n    if (!(channel in this._subs)) {\n      this._subs[channel] = sub;\n    }\n\n    if (!this.isConnected()) {\n      // subscribe will be called later\n      sub._setNew();\n      return;\n    }\n\n    sub._setSubscribing(isResubscribe);\n\n    const msg = {\n      method: this._methodType.SUBSCRIBE,\n      params: {\n        channel: channel\n      }\n    };\n\n    // If channel name does not start with privateChannelPrefix - then we\n    // can just send subscription message to Centrifuge. If channel name\n    // starts with privateChannelPrefix - then this is a private channel\n    // and we should ask web application backend for permission first.\n    if (startsWith(channel, this._config.privateChannelPrefix)) {\n      // private channel.\n      if (this._isSubscribeBatching) {\n        this._privateChannels[channel] = true;\n      } else {\n        this.startSubscribeBatching();\n        this._subscribe(sub);\n        this.stopSubscribeBatching();\n      }\n    } else {\n      const recover = sub._needRecover();\n\n      if (recover === true) {\n        msg.params.recover = true;\n        const seq = this._getLastSeq(channel);\n        const gen = this._getLastGen(channel);\n        if (seq || gen) {\n          if (seq) {\n            msg.params.seq = seq;\n          }\n          if (gen) {\n            msg.params.gen = gen;\n          }\n        } else {\n          const offset = this._getLastOffset(channel);\n          if (offset) {\n            msg.params.offset = offset;\n          }\n        }\n        const epoch = this._getLastEpoch(channel);\n        if (epoch) {\n          msg.params.epoch = epoch;\n        }\n      }\n\n      this._call(msg).then(resolveCtx => {\n        this._subscribeResponse(\n          channel,\n          recover,\n          this._decoder.decodeCommandResult(this._methodType.SUBSCRIBE, resolveCtx.result)\n        );\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        this._subscribeError(channel, rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    }\n  };\n\n  _unsubscribe(sub) {\n    delete this._subs[sub.channel];\n    delete this._lastOffset[sub.channel];\n    delete this._lastSeq[sub.channel];\n    delete this._lastGen[sub.channel];\n    if (this.isConnected()) {\n      // No need to unsubscribe in disconnected state - i.e. client already unsubscribed.\n      this._addMessage({\n        method: this._methodType.UNSUBSCRIBE,\n        params: {\n          channel: sub.channel\n        }\n      });\n    }\n  };\n\n  _getTTLMilliseconds(ttl) {\n    // https://stackoverflow.com/questions/12633405/what-is-the-maximum-delay-for-setinterval\n    return Math.min(ttl * 1000, 2147483647);\n  }\n\n  getSub(channel) {\n    return this._getSub(channel);\n  }\n\n  _getSub(channel) {\n    const sub = this._subs[channel];\n    if (!sub) {\n      return null;\n    }\n    return sub;\n  };\n\n  _isServerSub(channel) {\n    return this._serverSubs[channel] !== undefined;\n  };\n\n  _connectResponse(result, isRecover) {\n    const wasReconnecting = this._reconnecting;\n    this._reconnecting = false;\n    this._resetRetry();\n    this._refreshRequired = false;\n\n    if (this.isConnected()) {\n      return;\n    }\n\n    if (this._latencyStart !== null) {\n      this._latency = (new Date()).getTime() - this._latencyStart.getTime();\n      this._latencyStart = null;\n    }\n\n    this._clientID = result.client;\n    this._setStatus('connected');\n\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n    }\n\n    if (result.expires) {\n      this._refreshTimeout = setTimeout(() => this._refresh(), this._getTTLMilliseconds(result.ttl));\n    }\n\n    this.startBatching();\n    this.startSubscribeBatching();\n    for (const channel in this._subs) {\n      if (this._subs.hasOwnProperty(channel)) {\n        const sub = this._subs[channel];\n        if (sub._shouldResubscribe()) {\n          this._subscribe(sub, wasReconnecting);\n        }\n      }\n    }\n    this.stopSubscribeBatching();\n    this.stopBatching();\n\n    this._startPing();\n\n    const ctx = {\n      client: result.client,\n      transport: this._transportName,\n      latency: this._latency\n    };\n    if (result.data) {\n      ctx.data = result.data;\n    }\n\n    this.emit('connect', ctx);\n\n    if (result.subs) {\n      this._processServerSubs(result.subs, isRecover);\n    }\n  };\n\n  _processServerSubs(subs, isRecover) {\n    for (const channel in subs) {\n      if (subs.hasOwnProperty(channel)) {\n        const sub = subs[channel];\n        const isResubscribe = this._serverSubs[channel] !== undefined;\n        let subCtx = {channel: channel, isResubscribe: isResubscribe};\n        subCtx = this._expandSubscribeContext(subCtx, sub);\n        this.emit('subscribe', subCtx);\n      }\n    }\n    for (const channel in subs) {\n      if (subs.hasOwnProperty(channel)) {\n        const sub = subs[channel];\n        if (sub.recovered) {\n          let pubs = sub.publications;\n          if (pubs && pubs.length > 0) {\n\n            // handle legacy order.\n            // TODO: remove as soon as Centrifuge v1 released.\n            if (pubs.length > 1 && (!pubs[0].offset || pubs[0].offset > pubs[1].offset)) {\n              pubs = pubs.reverse();\n            }\n\n            for (let i in pubs) {\n              if (pubs.hasOwnProperty(i)) {\n                this._handlePublication(channel, pubs[i]);\n              }\n            }\n          }\n        }\n        this._serverSubs[channel] = {\n          'seq': sub.seq,\n          'gen': sub.gen,\n          'offset': sub.offset,\n          'epoch': sub.epoch,\n          'recoverable': sub.recoverable\n        };\n      }\n    }\n  };\n\n  _stopPing() {\n    if (this._pongTimeout !== null) {\n      clearTimeout(this._pongTimeout);\n      this._pongTimeout = null;\n    }\n    if (this._pingTimeout !== null) {\n      clearTimeout(this._pingTimeout);\n      this._pingTimeout = null;\n    }\n  };\n\n  _startPing() {\n    if (this._config.ping !== true || this._config.pingInterval <= 0) {\n      return;\n    }\n    if (!this.isConnected()) {\n      return;\n    }\n\n    this._pingTimeout = setTimeout(() => {\n      if (!this.isConnected()) {\n        this._stopPing();\n        return;\n      }\n      this.ping();\n      this._pongTimeout = setTimeout(() => {\n        this._disconnect('no ping', true);\n      }, this._config.pongWaitTimeout);\n    }, this._config.pingInterval);\n  };\n\n  _restartPing() {\n    this._stopPing();\n    this._startPing();\n  };\n\n  _subscribeError(channel, error) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    if (!sub._isSubscribing()) {\n      return;\n    }\n    if (error.code === 0 && error.message === _errorTimeout) { // client side timeout.\n      this._disconnect('timeout', true);\n      return;\n    }\n    sub._setSubscribeError(error);\n  };\n\n  _expandSubscribeContext(ctx, result) {\n    let recovered = false;\n    if ('recovered' in result) {\n      recovered = result.recovered;\n    }\n    ctx.recovered = recovered;\n\n    let positioned = false;\n    if ('positioned' in result) {\n      positioned = result.positioned;\n    }\n    let epoch = '';\n    if ('epoch' in result) {\n      epoch = result.epoch;\n    }\n    let offset = 0;\n    if ('offset' in result) {\n      offset = result.offset;\n    }\n    if (positioned) {\n      ctx.streamPosition = {\n        'offset': offset,\n        'epoch': epoch\n      };\n    };\n    return ctx;\n  }\n\n  _subscribeResponse(channel, isRecover, result) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    if (!sub._isSubscribing()) {\n      return;\n    }\n    sub._setSubscribeSuccess(result);\n\n    let pubs = result.publications;\n    if (pubs && pubs.length > 0) {\n      if (pubs.length >= 2 && !pubs[0].offset && !pubs[1].offset) {\n        // handle legacy order.\n        pubs = pubs.reverse();\n      }\n      for (let i in pubs) {\n        if (pubs.hasOwnProperty(i)) {\n          this._handlePublication(channel, pubs[i]);\n        }\n      }\n    }\n\n    if (result.recoverable && (!isRecover || !result.recovered)) {\n      this._lastSeq[channel] = result.seq || 0;\n      this._lastGen[channel] = result.gen || 0;\n      this._lastOffset[channel] = result.offset || 0;\n    }\n\n    this._lastEpoch[channel] = result.epoch || '';\n\n    if (result.recoverable) {\n      sub._recoverable = true;\n    }\n\n    if (result.expires === true) {\n      let subRefreshTimeout = setTimeout(() => this._subRefresh(channel), this._getTTLMilliseconds(result.ttl));\n      this._subRefreshTimeouts[channel] = subRefreshTimeout;\n    }\n  };\n\n  _handleReply(reply, next) {\n    const id = reply.id;\n    const result = reply.result;\n\n    if (!(id in this._callbacks)) {\n      next();\n      return;\n    }\n    const callbacks = this._callbacks[id];\n    clearTimeout(this._callbacks[id].timeout);\n    delete this._callbacks[id];\n\n    if (!errorExists(reply)) {\n      const callback = callbacks.callback;\n      if (!callback) {\n        return;\n      }\n      callback({result, next});\n    } else {\n      const errback = callbacks.errback;\n      if (!errback) {\n        next();\n        return;\n      }\n      const error = reply.error;\n      errback({error, next});\n    }\n  }\n\n  _handleJoin(channel, join) {\n    const ctx = {'info': join.info};\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        ctx.channel = channel;\n        this.emit('join', ctx);\n      }\n      return;\n    }\n    sub.emit('join', ctx);\n  };\n\n  _handleLeave(channel, leave) {\n    const ctx = {'info': leave.info};\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        ctx.channel = channel;\n        this.emit('leave', ctx);\n      }\n      return;\n    }\n    sub.emit('leave', ctx);\n  };\n\n  _handleUnsub(channel, unsub) {\n    const ctx = {};\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        delete this._serverSubs[channel];\n        ctx.channel = channel;\n        this.emit('unsubscribe', ctx);\n      }\n      return;\n    }\n    sub.unsubscribe();\n    if (unsub.resubscribe === true) {\n      sub.subscribe();\n    }\n  };\n\n  _handleSub(channel, sub) {\n    this._serverSubs[channel] = {\n      'seq': sub.seq,\n      'gen': sub.gen,\n      'offset': sub.offset,\n      'epoch': sub.epoch,\n      'recoverable': sub.recoverable\n    };\n    let ctx = {'channel': channel, isResubscribe: false};\n    ctx = this._expandSubscribeContext(ctx, sub);\n    this.emit('subscribe', ctx);\n  };\n\n  _handlePublication(channel, pub) {\n    const sub = this._getSub(channel);\n    const ctx = {\n      'data': pub.data,\n      'seq': pub.seq,\n      'gen': pub.gen,\n      'offset': pub.offset\n    };\n    if (pub.info) {\n      ctx.info = pub.info;\n    }\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        if (pub.seq !== undefined) {\n          this._serverSubs[channel].seq = pub.seq;\n        }\n        if (pub.gen !== undefined) {\n          this._serverSubs[channel].gen = pub.gen;\n        }\n        if (pub.offset !== undefined) {\n          this._serverSubs[channel].offset = pub.offset;\n        }\n        ctx.channel = channel;\n        this.emit('publish', ctx);\n      }\n      return;\n    }\n    if (pub.seq !== undefined) {\n      this._lastSeq[channel] = pub.seq;\n    }\n    if (pub.gen !== undefined) {\n      this._lastGen[channel] = pub.gen;\n    }\n    if (pub.offset !== undefined) {\n      this._lastOffset[channel] = pub.offset;\n    }\n    sub.emit('publish', ctx);\n  };\n\n  _handleMessage(message) {\n    this.emit('message', message.data);\n  };\n\n  _handlePush(data, next) {\n    const push = this._decoder.decodePush(data);\n    let type = 0;\n    if ('type' in push) {\n      type = push['type'];\n    }\n    const channel = push.channel;\n\n    if (type === this._pushType.PUBLICATION) {\n      const pub = this._decoder.decodePushData(this._pushType.PUBLICATION, push.data);\n      this._handlePublication(channel, pub);\n    } else if (type === this._pushType.MESSAGE) {\n      const message = this._decoder.decodePushData(this._pushType.MESSAGE, push.data);\n      this._handleMessage(message);\n    } else if (type === this._pushType.JOIN) {\n      const join = this._decoder.decodePushData(this._pushType.JOIN, push.data);\n      this._handleJoin(channel, join);\n    } else if (type === this._pushType.LEAVE) {\n      const leave = this._decoder.decodePushData(this._pushType.LEAVE, push.data);\n      this._handleLeave(channel, leave);\n    } else if (type === this._pushType.UNSUB) {\n      const unsub = this._decoder.decodePushData(this._pushType.UNSUB, push.data);\n      this._handleUnsub(channel, unsub);\n    } else if (type === this._pushType.SUB) {\n      const sub = this._decoder.decodePushData(this._pushType.SUB, push.data);\n      this._handleSub(channel, sub);\n    }\n    next();\n  }\n\n  _flush() {\n    const messages = this._messages.slice(0);\n    this._messages = [];\n    this._transportSend(messages);\n  };\n\n  _ping() {\n    const msg = {\n      method: this._methodType.PING\n    };\n    this._call(msg).then(resolveCtx => {\n      this._pingResponse(this._decoder.decodeCommandResult(this._methodType.PING, resolveCtx.result));\n      if (resolveCtx.next) {\n        resolveCtx.next();\n      }\n    }, rejectCtx => {\n      this._debug('ping error', rejectCtx.error);\n      if (rejectCtx.next) {\n        rejectCtx.next();\n      }\n    });\n  };\n\n  _pingResponse(result) {\n    if (!this.isConnected()) {\n      return;\n    }\n    this._stopPing();\n    this._startPing();\n  }\n\n  _getLastSeq(channel) {\n    const lastSeq = this._lastSeq[channel];\n    if (lastSeq) {\n      return lastSeq;\n    }\n    return 0;\n  };\n\n  _getLastOffset(channel) {\n    const lastOffset = this._lastOffset[channel];\n    if (lastOffset) {\n      return lastOffset;\n    }\n    return 0;\n  };\n\n  _getLastGen(channel) {\n    const lastGen = this._lastGen[channel];\n    if (lastGen) {\n      return lastGen;\n    }\n    return 0;\n  };\n\n  _getLastEpoch(channel) {\n    const lastEpoch = this._lastEpoch[channel];\n    if (lastEpoch) {\n      return lastEpoch;\n    }\n    return '';\n  };\n\n  _createErrorObject(message, code) {\n    const errObject = {\n      message: message,\n      code: code || 0\n    };\n\n    return errObject;\n  };\n\n  _registerCall(id, callback, errback) {\n    this._callbacks[id] = {\n      callback: callback,\n      errback: errback,\n      timeout: null\n    };\n    this._callbacks[id].timeout = setTimeout(() => {\n      delete this._callbacks[id];\n      if (isFunction(errback)) {\n        errback({error: this._createErrorObject(_errorTimeout)});\n      }\n    }, this._config.timeout);\n  };\n\n  _addMessage(message) {\n    let id = this._nextMessageId();\n    message.id = id;\n    if (this._isBatching === true) {\n      this._messages.push(message);\n    } else {\n      this._transportSend([message]);\n    }\n    return id;\n  };\n\n  isConnected() {\n    return this._isConnected();\n  }\n\n  connect() {\n    this._connect();\n  };\n\n  disconnect() {\n    this._disconnect('client', false);\n  };\n\n  ping() {\n    return this._ping();\n  }\n\n  startBatching() {\n    // start collecting messages without sending them to Centrifuge until flush\n    // method called\n    this._isBatching = true;\n  };\n\n  stopBatching() {\n    this._isBatching = false;\n    this._flush();\n  };\n\n  startSubscribeBatching() {\n    // start collecting private channels to create bulk authentication\n    // request to subscribeEndpoint when stopSubscribeBatching will be called\n    this._isSubscribeBatching = true;\n  };\n\n  stopSubscribeBatching() {\n    // create request to subscribeEndpoint with collected private channels\n    // to ask if this client can subscribe on each channel\n    this._isSubscribeBatching = false;\n    const authChannels = this._privateChannels;\n    this._privateChannels = {};\n\n    const channels = [];\n\n    for (const channel in authChannels) {\n      if (authChannels.hasOwnProperty(channel)) {\n        const sub = this._getSub(channel);\n        if (!sub) {\n          continue;\n        }\n        channels.push(channel);\n      }\n    }\n\n    if (channels.length === 0) {\n      this._debug('no private channels found, no need to make request');\n      return;\n    }\n\n    const data = {\n      client: this._clientID,\n      channels: channels\n    };\n\n    const clientID = this._clientID;\n    const xhrID = this._newXHRID();\n\n    const cb = (resp) => {\n      if (xhrID in this._xhrs) {\n        delete this._xhrs[xhrID];\n      }\n      if (this._clientID !== clientID) {\n        return;\n      }\n      if (resp.error || resp.status !== 200) {\n        this._debug('authorization request failed');\n        for (const i in channels) {\n          if (channels.hasOwnProperty(i)) {\n            const channel = channels[i];\n            this._subscribeError(channel, this._createErrorObject('authorization request failed'));\n          }\n        }\n        return;\n      }\n\n      let channelsData = {};\n      if (resp.data.channels) {\n        for (const i in resp.data.channels) {\n          const channelData = resp.data.channels[i];\n          if (!channelData.channel) {\n            continue;\n          }\n          channelsData[channelData.channel] = channelData.token;\n        }\n      }\n\n      // try to send all subscriptions in one request.\n      let batch = false;\n\n      if (!this._isBatching) {\n        this.startBatching();\n        batch = true;\n      }\n\n      for (const i in channels) {\n        if (channels.hasOwnProperty(i)) {\n          const channel = channels[i];\n          const token = channelsData[channel];\n\n          if (!token) {\n            // subscription:error\n            this._subscribeError(channel, this._createErrorObject('permission denied', 103));\n            continue;\n          } else {\n            const msg = {\n              method: this._methodType.SUBSCRIBE,\n              params: {\n                channel: channel,\n                token: token\n              }\n            };\n\n            const sub = this._getSub(channel);\n            if (sub === null) {\n              continue;\n            }\n\n            const recover = sub._needRecover();\n\n            if (recover === true) {\n              msg.params.recover = true;\n              const seq = this._getLastSeq(channel);\n              const gen = this._getLastGen(channel);\n              if (seq || gen) {\n                if (seq) {\n                  msg.params.seq = seq;\n                }\n                if (gen) {\n                  msg.params.gen = gen;\n                }\n              } else {\n                const offset = this._getLastOffset(channel);\n                if (offset) {\n                  msg.params.offset = offset;\n                }\n              }\n              const epoch = this._getLastEpoch(channel);\n              if (epoch) {\n                msg.params.epoch = epoch;\n              }\n            }\n            this._call(msg).then(resolveCtx => {\n              this._subscribeResponse(\n                channel,\n                recover,\n                this._decoder.decodeCommandResult(this._methodType.SUBSCRIBE, resolveCtx.result)\n              );\n              if (resolveCtx.next) {\n                resolveCtx.next();\n              }\n            }, rejectCtx => {\n              this._subscribeError(channel, rejectCtx.error);\n              if (rejectCtx.next) {\n                rejectCtx.next();\n              }\n            });\n          }\n        }\n      }\n\n      if (batch) {\n        this.stopBatching();\n      }\n\n    };\n\n    if (this._config.onPrivateSubscribe !== null) {\n      this._config.onPrivateSubscribe({\n        data: data\n      }, cb);\n    } else {\n      const xhr = this._ajax(\n        this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n      this._xhrs[xhrID] = xhr;\n    }\n  };\n\n  subscribe(channel, events) {\n    const currentSub = this._getSub(channel);\n    if (currentSub !== null) {\n      currentSub._setEvents(events);\n      if (currentSub._isUnsubscribed()) {\n        currentSub.subscribe();\n      }\n      return currentSub;\n    }\n    const sub = new Subscription(this, channel, events);\n    this._subs[channel] = sub;\n    sub.subscribe();\n    return sub;\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/centrifuge.js","import EventEmitter from 'events';\n\nimport {\n  isFunction\n} from './utils';\n\nconst _STATE_NEW = 0;\nconst _STATE_SUBSCRIBING = 1;\nconst _STATE_SUCCESS = 2;\nconst _STATE_ERROR = 3;\nconst _STATE_UNSUBSCRIBED = 4;\n\nexport default class Subscription extends EventEmitter {\n  constructor(centrifuge, channel, events) {\n    super();\n    this.channel = channel;\n    this._centrifuge = centrifuge;\n    this._status = _STATE_NEW;\n    this._error = null;\n    this._isResubscribe = false;\n    this._ready = false;\n    this._subscriptionPromise = null;\n    this._noResubscribe = false;\n    this._recoverable = false;\n    this._recover = false;\n    this._setEvents(events);\n    this._initializePromise();\n    this._promises = {};\n    this._promiseId = 0;\n    this.on('error', function (errContext) {\n      this._centrifuge._debug('subscription error', errContext);\n    });\n  }\n\n  _nextPromiseId() {\n    return ++this._promiseId;\n  }\n\n  _initializePromise() {\n    // this helps us to wait until subscription will successfully\n    // subscribe and call actions such as presence, history etc in\n    // synchronous way.\n    this._ready = false;\n\n    this._subscriptionPromise = new Promise((resolve, reject) => {\n      this._resolve = value => {\n        this._ready = true;\n        resolve(value);\n      };\n      this._reject = err => {\n        this._ready = true;\n        reject(err);\n      };\n    }).then(function () {}, function () {});\n  };\n\n  _needRecover() {\n    return this._recoverable === true && this._recover === true;\n  };\n\n  _setEvents(events) {\n    if (!events) {\n      return;\n    }\n    if (isFunction(events)) {\n      // events is just a function to handle publication received from channel.\n      this.on('publish', events);\n    } else if (Object.prototype.toString.call(events) === Object.prototype.toString.call({})) {\n      const knownEvents = ['publish', 'join', 'leave', 'unsubscribe', 'subscribe', 'error'];\n      for (let i = 0, l = knownEvents.length; i < l; i++) {\n        const ev = knownEvents[i];\n        if (ev in events) {\n          this.on(ev, events[ev]);\n        }\n      }\n    }\n  };\n\n  _isNew() {\n    return this._status === _STATE_NEW;\n  };\n\n  _isUnsubscribed() {\n    return this._status === _STATE_UNSUBSCRIBED;\n  };\n\n  _isSubscribing() {\n    return this._status === _STATE_SUBSCRIBING;\n  };\n\n  _isReady() {\n    return this._status === _STATE_SUCCESS || this._status === _STATE_ERROR;\n  };\n\n  _isSuccess() {\n    return this._status === _STATE_SUCCESS;\n  };\n\n  _isError() {\n    return this._status === _STATE_ERROR;\n  };\n\n  _setNew() {\n    this._status = _STATE_NEW;\n  };\n\n  _setSubscribing(isResubscribe) {\n    this._isResubscribe = isResubscribe || false;\n    if (this._ready === true) {\n      // new promise for this subscription\n      this._initializePromise();\n    }\n    this._status = _STATE_SUBSCRIBING;\n  };\n\n  _setSubscribeSuccess(subCtx) {\n    if (this._status === _STATE_SUCCESS) {\n      return;\n    }\n    this._status = _STATE_SUCCESS;\n    const successContext = subCtx;\n    this._recover = false;\n    this.emit('subscribe', successContext);\n    this._resolve(successContext);\n    for (const id in this._promises) {\n      clearTimeout(this._promises[id].timeout);\n      this._promises[id].resolve();\n      delete this._promises[id];\n    }\n  };\n\n  _setSubscribeError(err) {\n    if (this._status === _STATE_ERROR) {\n      return;\n    }\n    this._status = _STATE_ERROR;\n    this._error = err;\n    const errContext = this._getSubscribeErrorContext();\n    this.emit('error', errContext);\n    this._reject(errContext);\n    for (const id in this._promises) {\n      clearTimeout(this._promises[id].timeout);\n      this._promises[id].reject(err);\n      delete this._promises[id];\n    }\n  };\n\n  _triggerUnsubscribe() {\n    this.emit('unsubscribe', {\n      channel: this.channel\n    });\n  };\n\n  _setUnsubscribed(noResubscribe) {\n    this._centrifuge._clearSubRefreshTimeout(this.channel);\n    if (this._status === _STATE_UNSUBSCRIBED) {\n      return;\n    }\n    const needTrigger = this._status === _STATE_SUCCESS;\n    this._status = _STATE_UNSUBSCRIBED;\n    if (noResubscribe === true) {\n      this._recover = false;\n      this._noResubscribe = true;\n      delete this._centrifuge._lastSeq[this.channel];\n      delete this._centrifuge._lastGen[this.channel];\n      delete this._centrifuge._lastEpoch[this.channel];\n    }\n    if (needTrigger) {\n      this._triggerUnsubscribe();\n    }\n  };\n\n  _shouldResubscribe() {\n    return !this._noResubscribe;\n  };\n\n  _getSubscribeSuccessContext(subscribeResult) {\n    let ctx = {\n      channel: this.channel,\n      isResubscribe: this._isResubscribe\n    };\n    ctx = this._centrifuge._expandSubscribeContext(ctx, subscribeResult);\n    return ctx;\n  };\n\n  _getSubscribeErrorContext() {\n    const subscribeErrorContext = this._error;\n    subscribeErrorContext.channel = this.channel;\n    subscribeErrorContext.isResubscribe = this._isResubscribe;\n    return subscribeErrorContext;\n  };\n\n  ready(callback, errback) {\n    if (this._ready) {\n      if (this._isSuccess()) {\n        callback(this._getSubscribeSuccessContext());\n      } else {\n        errback(this._getSubscribeErrorContext());\n      }\n    }\n  };\n\n  subscribe() {\n    if (this._status === _STATE_SUCCESS) {\n      return;\n    }\n    this._noResubscribe = false;\n    this._centrifuge._subscribe(this);\n  };\n\n  unsubscribe() {\n    this._setUnsubscribed(true);\n    this._centrifuge._unsubscribe(this);\n  };\n\n  _methodCall(message, type) {\n    const methodCallPromise = new Promise((resolve, reject) => {\n      let subPromise;\n      if (this._isSuccess()) {\n        subPromise = Promise.resolve();\n      } else if (this._isError()) {\n        subPromise = Promise.reject(this._error);\n      } else {\n        subPromise = new Promise((res, rej) => {\n          const timeout = setTimeout(function () {\n            rej({'code': 0, 'message': 'timeout'});\n          }, this._centrifuge._config.timeout);\n          this._promises[this._nextPromiseId()] = {\n            timeout: timeout,\n            resolve: res,\n            reject: rej\n          };\n        });\n      }\n      subPromise.then(\n        () => {\n          return this._centrifuge._call(message).then(\n            resolveCtx => {\n              resolve(this._centrifuge._decoder.decodeCommandResult(type, resolveCtx.result));\n              if (resolveCtx.next) {\n                resolveCtx.next();\n              }\n            },\n            rejectCtx => {\n              reject(rejectCtx.error);\n              if (rejectCtx.next) {\n                rejectCtx.next();\n              }\n            }\n          );\n        },\n        error => {\n          reject(error);\n        }\n      );\n    });\n    return methodCallPromise;\n  }\n\n  publish(data) {\n    return this._methodCall({\n      method: this._centrifuge._methodType.PUBLISH,\n      params: {\n        channel: this.channel,\n        data: data\n      }\n    }, this._centrifuge._methodType.PUBLISH);\n  };\n\n  presence() {\n    return this._methodCall({\n      method: this._centrifuge._methodType.PRESENCE,\n      params: {\n        channel: this.channel\n      }\n    }, this._centrifuge._methodType.PRESENCE);\n  };\n\n  presenceStats() {\n    return this._methodCall({\n      method: this._centrifuge._methodType.PRESENCE_STATS,\n      params: {\n        channel: this.channel\n      }\n    }, this._centrifuge._methodType.PRESENCE_STATS);\n  };\n\n  history(options) {\n    const params = this._centrifuge._getHistoryParams(this.channel, options);\n    return this._methodCall({\n      method: this._centrifuge._methodType.HISTORY,\n      params: params\n    }, this._centrifuge._methodType.HISTORY);\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/subscription.js","export const JsonMethodType = {\n  CONNECT: 0,\n  SUBSCRIBE: 1,\n  UNSUBSCRIBE: 2,\n  PUBLISH: 3,\n  PRESENCE: 4,\n  PRESENCE_STATS: 5,\n  HISTORY: 6,\n  PING: 7,\n  SEND: 8,\n  RPC: 9,\n  REFRESH: 10,\n  SUB_REFRESH: 11\n};\n\nexport const JsonPushType = {\n  PUBLICATION: 0,\n  JOIN: 1,\n  LEAVE: 2,\n  UNSUB: 3,\n  MESSAGE: 4,\n  SUB: 5\n};\n\nexport class JsonEncoder {\n  encodeCommands(commands) {\n    const encodedCommands = [];\n    for (const i in commands) {\n      if (commands.hasOwnProperty(i)) {\n        encodedCommands.push(JSON.stringify(commands[i]));\n      }\n    }\n    return encodedCommands.join('\\n');\n  }\n}\n\nexport class JsonDecoder {\n  decodeReplies(data) {\n    const replies = [];\n    const encodedReplies = data.split('\\n');\n    for (const i in encodedReplies) {\n      if (encodedReplies.hasOwnProperty(i)) {\n        if (!encodedReplies[i]) {\n          continue;\n        }\n        const reply = JSON.parse(encodedReplies[i]);\n        replies.push(reply);\n      }\n    }\n    return replies;\n  }\n\n  decodeCommandResult(methodType, data) {\n    return data;\n  }\n\n  decodePush(data) {\n    return data;\n  }\n\n  decodePushData(pushType, data) {\n    return data;\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/json.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 3\n// module chunks = 0 1","import {Centrifuge} from './centrifuge.js';\nexport default Centrifuge;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/events/events.js\n// module id = 6\n// module chunks = 0 1","export function startsWith(value, prefix) {\n  return value.lastIndexOf(prefix, 0) === 0;\n};\n\nexport function isFunction(value) {\n  if (value === undefined || value === null) {\n    return false;\n  }\n  return typeof value === 'function';\n};\n\nexport function log(level, args) {\n  if (global.console) {\n    const logger = global.console[level];\n\n    if (isFunction(logger)) {\n      logger.apply(global.console, args);\n    }\n  }\n};\n\nexport function backoff(step, min, max) {\n  const jitter = 0.5 * Math.random();\n  const interval = Math.min(max, min * Math.pow(2, step + 1));\n\n  return Math.floor((1 - jitter) * interval);\n};\n\nexport function errorExists(data) {\n  return 'error' in data && data.error !== null;\n};\n\nexport function extend(a, b) {\n  for (const key in b) {\n    if (b.hasOwnProperty(key)) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js"],"sourceRoot":""}