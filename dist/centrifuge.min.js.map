{"version":3,"sources":["webpack://Centrifuge/webpack/universalModuleDefinition","webpack://Centrifuge/./src/centrifuge.js","webpack://Centrifuge/./src/index.js","webpack://Centrifuge/./src/json.js","webpack://Centrifuge/./src/subscription.js","webpack://Centrifuge/./src/utils.js","webpack://Centrifuge/./node_modules/events/events.js","webpack://Centrifuge/webpack/bootstrap","webpack://Centrifuge/webpack/startup","webpack://Centrifuge/webpack/runtime/global"],"names":["root","factory","exports","module","define","amd","this","_errorTimeout","_errorConnectionClosed","Centrifuge","url","options","_url","_websocket","_sockjs","_isSockjs","_binary","_methodType","_pushType","_encoder","_decoder","_status","_reconnect","_reconnecting","_transport","_transportName","_transportClosed","_messageId","_clientID","_refreshRequired","_subs","_serverSubs","_lastSeq","_lastGen","_lastOffset","_lastEpoch","_messages","_isBatching","_isSubscribeBatching","_privateChannels","_numRefreshFailed","_refreshTimeout","_pingTimeout","_pongTimeout","_subRefreshTimeouts","_retries","_callbacks","_latency","_latencyStart","_connectData","_token","_xhrID","_xhrs","_dispatchPromise","Promise","resolve","_config","debug","name","version","websocket","sockjs","minRetry","maxRetry","timeout","ping","pingInterval","pongWaitTimeout","privateChannelPrefix","onTransportClose","sockjsServer","sockjsTransports","refreshEndpoint","refreshHeaders","refreshParams","refreshData","refreshAttempts","refreshInterval","onRefreshFailed","onRefresh","subscribeEndpoint","subscribeHeaders","subscribeParams","subRefreshInterval","onPrivateSubscribe","_configure","token","data","headers","params","callback","query","_debug","JSON","stringify","xhr","global","XMLHttpRequest","ActiveXObject","i","hasOwnProperty","length","encodeURIComponent","headerName","open","withCredentials","setRequestHeader","onreadystatechange","readyState","status","parsed","parse","responseText","e","error","_log","setTimeout","send","log","arguments","WebSocket","format","_formatOverride","Error","JsonMethodType","JsonPushType","JsonEncoder","JsonDecoder","configuration","extend","startsWith","indexOf","_setFormat","SockJS","newStatus","interval","backoff","xhrID","abort","reconnect","id","_stopPing","callbacks","clearTimeout","errback","_createErrorObject","channel","sub","_isSuccess","_triggerUnsubscribe","_recover","_shouldResubscribe","_setSubscribing","_setUnsubscribed","_abortInflightXHRs","_clearSubRefreshTimeout","transport","OPEN","commands","_isTransportOpen","command","encodeCommands","sockjsOptions","transports","server","_websocketSupported","binaryType","onopen","onheartbeat","_restartPing","msg","subs","hasSubs","recoverable","seq","gen","offset","epoch","Date","_call","then","resolveCtx","_connectResponse","decodeCommandResult","CONNECT","result","next","rejectCtx","code","_disconnect","onerror","onclose","closeEvent","reason","needReconnect","advice","event","_getRetryInterval","_refresh","_connect","onmessage","_dataReceived","_rpc","method","RPC","_methodCall","SEND","isConnected","_transportSend","reject","undefined","since","limit","resultCB","PUBLISH","_getHistoryParams","HISTORY","PRESENCE","PRESENCE_STATS","replies","decodeReplies","finishDispatch","_dispatchSynchronized","p","_dispatchReply","reply","_handleReply","_handlePush","_addMessage","_registerCall","_setStatus","_setupTransport","shouldReconnect","_isDisconnected","_clearConnectedState","emit","close","_refreshFailed","clientID","_newXHRID","cb","resp","jitter","Math","round","random","max","REFRESH","_refreshResponse","_refreshError","_ajax","err","expires","client","_getTTLMilliseconds","ttl","channelsData","channels","channelData","SUB_REFRESH","_getSub","_subRefreshResponse","_subRefreshError","subRefreshTimeout","_subRefresh","isResubscribe","SUBSCRIBE","startSubscribeBatching","_subscribe","stopSubscribeBatching","recover","_needRecover","_getLastSeq","_getLastGen","_getLastOffset","_getLastEpoch","_subscribeResponse","_subscribeError","_setNew","UNSUBSCRIBE","min","isRecover","wasReconnecting","_resetRetry","getTime","startBatching","stopBatching","_startPing","ctx","latency","_processServerSubs","subCtx","_expandSubscribeContext","recovered","pubs","publications","reverse","_handlePublication","_isSubscribing","message","_setSubscribeError","positioned","streamPosition","_setSubscribeSuccess","_recoverable","errorExists","join","info","_isServerSub","leave","unsub","unsubscribe","resubscribe","subscribe","pub","push","decodePush","type","PUBLICATION","decodePushData","MESSAGE","_handleMessage","JOIN","_handleJoin","LEAVE","_handleLeave","UNSUB","_handleUnsub","SUB","_handleSub","messages","slice","PING","_pingResponse","isFunction","_nextMessageId","_isConnected","_ping","_flush","authChannels","batch","events","currentSub","_setEvents","_isUnsubscribed","Subscription","EventEmitter","encodedCommands","encodedReplies","split","methodType","pushType","centrifuge","_centrifuge","_error","_isResubscribe","_ready","_subscriptionPromise","_noResubscribe","_initializePromise","_promises","_promiseId","on","errContext","_resolve","value","_reject","Object","prototype","toString","call","knownEvents","l","ev","subscribeResult","successContext","_getSubscribeSuccessContext","_getSubscribeErrorContext","noResubscribe","needTrigger","subscribeErrorContext","_unsubscribe","_isError","res","rej","_nextPromiseId","prefix","lastIndexOf","level","args","console","logger","apply","step","pow","floor","a","b","key","ReflectOwnKeys","R","Reflect","ReflectApply","target","receiver","Function","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","init","once","emitter","eventListener","errorListener","removeListener","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","prepend","m","existing","warning","create","newListener","unshift","warned","w","String","count","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","Array","unwrapListeners","arrayClone","listenerCount","n","copy","defineProperty","enumerable","get","set","arg","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","context","handler","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","keys","rawListeners","eventNames","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","g","globalThis","window"],"mappings":"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","file":"centrifuge.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Centrifuge\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Centrifuge\"] = factory();\n\telse\n\t\troot[\"Centrifuge\"] = factory();\n})(this, function() {\nreturn ","import EventEmitter from 'events';\nimport Subscription from './subscription';\n\nimport {\n  JsonEncoder,\n  JsonDecoder,\n  JsonMethodType,\n  JsonPushType\n} from './json';\n\nimport {\n  isFunction,\n  log,\n  startsWith,\n  errorExists,\n  backoff,\n  extend\n} from './utils';\n\nconst _errorTimeout = 'timeout';\nconst _errorConnectionClosed = 'connection closed';\n\nexport class Centrifuge extends EventEmitter {\n\n  constructor(url, options) {\n    super();\n    this._url = url;\n    this._websocket = null;\n    this._sockjs = null;\n    this._isSockjs = false;\n    this._binary = false;\n    this._methodType = null;\n    this._pushType = null;\n    this._encoder = null;\n    this._decoder = null;\n    this._status = 'disconnected';\n    this._reconnect = true;\n    this._reconnecting = false;\n    this._transport = null;\n    this._transportName = null;\n    this._transportClosed = true;\n    this._messageId = 0;\n    this._clientID = null;\n    this._refreshRequired = false;\n    this._subs = {};\n    this._serverSubs = {};\n    this._lastSeq = {};\n    this._lastGen = {};\n    this._lastOffset = {};\n    this._lastEpoch = {};\n    this._messages = [];\n    this._isBatching = false;\n    this._isSubscribeBatching = false;\n    this._privateChannels = {};\n    this._numRefreshFailed = 0;\n    this._refreshTimeout = null;\n    this._pingTimeout = null;\n    this._pongTimeout = null;\n    this._subRefreshTimeouts = {};\n    this._retries = 0;\n    this._callbacks = {};\n    this._latency = null;\n    this._latencyStart = null;\n    this._connectData = null;\n    this._token = null;\n    this._xhrID = 0;\n    this._xhrs = {};\n    this._dispatchPromise = Promise.resolve();\n    this._config = {\n      debug: false,\n      name: '',\n      version: '',\n      websocket: null,\n      sockjs: null,\n      minRetry: 1000,\n      maxRetry: 20000,\n      timeout: 5000,\n      ping: true,\n      pingInterval: 25000,\n      pongWaitTimeout: 5000,\n      privateChannelPrefix: '$',\n      onTransportClose: null,\n      sockjsServer: null,\n      sockjsTransports: [\n        'websocket',\n        'xdr-streaming',\n        'xhr-streaming',\n        'eventsource',\n        'iframe-eventsource',\n        'iframe-htmlfile',\n        'xdr-polling',\n        'xhr-polling',\n        'iframe-xhr-polling',\n        'jsonp-polling'\n      ],\n      refreshEndpoint: '/centrifuge/refresh',\n      refreshHeaders: {},\n      refreshParams: {},\n      refreshData: {},\n      refreshAttempts: null,\n      refreshInterval: 1000,\n      onRefreshFailed: null,\n      onRefresh: null,\n      subscribeEndpoint: '/centrifuge/subscribe',\n      subscribeHeaders: {},\n      subscribeParams: {},\n      subRefreshInterval: 1000,\n      onPrivateSubscribe: null\n    };\n    this._configure(options);\n  }\n\n  setToken(token) {\n    this._token = token;\n  }\n\n  setConnectData(data) {\n    this._connectData = data;\n  }\n\n  setRefreshHeaders(headers) {\n    this._config.refreshHeaders = headers;\n  }\n  setRefreshParams(params) {\n    this._config.refreshParams = params;\n  }\n  setRefreshData(data) {\n    this._config.refreshData = data;\n  }\n\n  setSubscribeHeaders(headers) {\n    this._config.subscribeHeaders = headers;\n  }\n  setSubscribeParams(params) {\n    this._config.subscribeParams = params;\n  }\n\n  _ajax(url, params, headers, data, callback) {\n    let query = '';\n    this._debug('sending AJAX request to', url, 'with data', JSON.stringify(data));\n\n    const xhr = (global.XMLHttpRequest ? new global.XMLHttpRequest() : new global.ActiveXObject('Microsoft.XMLHTTP'));\n\n    for (const i in params) {\n      if (params.hasOwnProperty(i)) {\n        if (query.length > 0) {\n          query += '&';\n        }\n        query += encodeURIComponent(i) + '=' + encodeURIComponent(params[i]);\n      }\n    }\n    if (query.length > 0) {\n      query = '?' + query;\n    }\n    xhr.open('POST', url + query, true);\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = true;\n    }\n\n    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    for (const headerName in headers) {\n      if (headers.hasOwnProperty(headerName)) {\n        xhr.setRequestHeader(headerName, headers[headerName]);\n      }\n    }\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200) {\n          let data, parsed = false;\n          try {\n            data = JSON.parse(xhr.responseText);\n            parsed = true;\n          } catch (e) {\n            callback({\n              error: 'Invalid JSON. Data was: ' + xhr.responseText,\n              status: 200,\n              data: null\n            });\n          }\n          if (parsed) { // prevents double execution.\n            callback({\n              data: data,\n              status: 200\n            });\n          }\n        } else {\n          this._log('wrong status code in AJAX response', xhr.status);\n          callback({\n            status: xhr.status,\n            data: null\n          });\n        }\n      }\n    };\n    setTimeout(() => xhr.send(JSON.stringify(data)), 20);\n    return xhr;\n  };\n\n  _log() {\n    log('info', arguments);\n  };\n\n  _debug() {\n    if (this._config.debug === true) {\n      log('debug', arguments);\n    }\n  };\n\n  _websocketSupported() {\n    if (this._config.websocket !== null) {\n      return true;\n    }\n    return !(typeof WebSocket !== 'function' && typeof WebSocket !== 'object');\n  };\n\n  _setFormat(format) {\n    if (this._formatOverride(format)) {\n      return;\n    }\n    if (format === 'protobuf') {\n      throw new Error('not implemented by JSON only Centrifuge client – use client with Protobuf');\n    }\n    this._binary = false;\n    this._methodType = JsonMethodType;\n    this._pushType = JsonPushType;\n    this._encoder = new JsonEncoder();\n    this._decoder = new JsonDecoder();\n  }\n\n  _formatOverride(format) {\n    return false;\n  }\n\n  _configure(configuration) {\n    if (!('Promise' in global)) {\n      throw new Error('Promise polyfill required');\n    }\n\n    extend(this._config, configuration || {});\n    this._debug('centrifuge config', this._config);\n\n    if (!this._url) {\n      throw new Error('url required');\n    }\n\n    if (startsWith(this._url, 'ws') && this._url.indexOf('format=protobuf') > -1) {\n      this._setFormat('protobuf');\n    } else {\n      this._setFormat('json');\n    }\n\n    if (startsWith(this._url, 'http')) {\n      this._debug('client will try to connect to SockJS endpoint');\n      if (this._config.sockjs !== null) {\n        this._debug('SockJS explicitly provided in options');\n        this._sockjs = this._config.sockjs;\n      } else {\n        if (typeof global.SockJS === 'undefined') {\n          throw new Error('SockJS not found, use ws:// in url or include SockJS');\n        }\n        this._debug('use globally defined SockJS');\n        this._sockjs = global.SockJS;\n      }\n    } else {\n      this._debug('client will connect to websocket endpoint');\n    }\n  };\n\n  _setStatus(newStatus) {\n    if (this._status !== newStatus) {\n      this._debug('Status', this._status, '->', newStatus);\n      this._status = newStatus;\n    }\n  };\n\n  _isDisconnected() {\n    return this._status === 'disconnected';\n  };\n\n  _isConnecting() {\n    return this._status === 'connecting';\n  };\n\n  _isConnected() {\n    return this._status === 'connected';\n  };\n\n  _nextMessageId() {\n    return ++this._messageId;\n  };\n\n  _resetRetry() {\n    this._debug('reset retries count to 0');\n    this._retries = 0;\n  };\n\n  _getRetryInterval() {\n    const interval = backoff(this._retries, this._config.minRetry, this._config.maxRetry);\n\n    this._retries += 1;\n    return interval;\n  };\n\n  _abortInflightXHRs() {\n    for (const xhrID in this._xhrs) {\n      try {\n        this._xhrs[xhrID].abort();\n      } catch (e) {\n        this._debug('error aborting xhr', e);\n      }\n      delete this._xhrs[xhrID];\n    }\n  };\n\n  _clearConnectedState(reconnect) {\n    this._clientID = null;\n    this._stopPing();\n\n    // fire errbacks of registered outgoing calls.\n    for (const id in this._callbacks) {\n      if (this._callbacks.hasOwnProperty(id)) {\n        const callbacks = this._callbacks[id];\n        clearTimeout(callbacks.timeout);\n        const errback = callbacks.errback;\n        if (!errback) {\n          continue;\n        }\n        errback({error: this._createErrorObject('disconnected')});\n      }\n    }\n    this._callbacks = {};\n\n    // fire unsubscribe events\n    for (const channel in this._subs) {\n      if (this._subs.hasOwnProperty(channel)) {\n        const sub = this._subs[channel];\n\n        if (reconnect) {\n          if (sub._isSuccess()) {\n            sub._triggerUnsubscribe();\n            sub._recover = true;\n          }\n          if (sub._shouldResubscribe()) {\n            sub._setSubscribing();\n          }\n        } else {\n          sub._setUnsubscribed();\n        }\n      }\n    }\n\n    this._abortInflightXHRs();\n\n    // clear refresh timer\n    if (this._refreshTimeout !== null) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n\n    // clear sub refresh timers\n    for (const channel in this._subRefreshTimeouts) {\n      if (this._subRefreshTimeouts.hasOwnProperty(channel) && this._subRefreshTimeouts[channel]) {\n        this._clearSubRefreshTimeout(channel);\n      }\n    }\n    this._subRefreshTimeouts = {};\n\n    if (!this._reconnect) {\n      // completely clear subscriptions\n      this._subs = {};\n    }\n  };\n\n  _isTransportOpen() {\n    if (this._isSockjs) {\n      return this._transport &&\n        this._transport.transport &&\n        this._transport.transport.readyState === this._transport.transport.OPEN;\n    }\n    return this._transport && this._transport.readyState === this._transport.OPEN;\n  };\n\n  _transportSend(commands) {\n    if (!commands.length) {\n      return true;\n    }\n\n    if (!this._isTransportOpen()) {\n      // resolve pending commands with error if transport is not open\n      for (let command in commands) {\n        let id = command.id;\n        if (!(id in this._callbacks)) {\n          continue;\n        }\n        const callbacks = this._callbacks[id];\n        clearTimeout(this._callbacks[id].timeout);\n        delete this._callbacks[id];\n        const errback = callbacks.errback;\n        errback({error: this._createErrorObject(_errorConnectionClosed, 0)});\n      }\n      return false;\n    }\n    this._transport.send(this._encoder.encodeCommands(commands));\n    return true;\n  }\n\n  _setupTransport() {\n    this._isSockjs = false;\n\n    // detect transport to use - SockJS or Websocket\n    if (this._sockjs !== null) {\n      const sockjsOptions = {\n        transports: this._config.sockjsTransports\n      };\n\n      if (this._config.sockjsServer !== null) {\n        sockjsOptions.server = this._config.sockjsServer;\n      }\n      this._isSockjs = true;\n      this._transport = new this._sockjs(this._url, null, sockjsOptions);\n    } else {\n      if (!this._websocketSupported()) {\n        this._debug('No Websocket support and no SockJS configured, can not connect');\n        return;\n      }\n      if (this._config.websocket !== null) {\n        this._websocket = this._config.websocket;\n      } else {\n        this._websocket = WebSocket;\n      }\n      this._transport = new this._websocket(this._url);\n      if (this._binary === true) {\n        this._transport.binaryType = 'arraybuffer';\n      }\n    }\n\n    this._transport.onopen = () => {\n      this._transportClosed = false;\n\n      if (this._isSockjs) {\n        this._transportName = 'sockjs-' + this._transport.transport;\n        this._transport.onheartbeat = () => this._restartPing();\n      } else {\n        this._transportName = 'websocket';\n      }\n\n      // Can omit method here due to zero value.\n      const msg = {\n        // method: this._methodType.CONNECT\n      };\n\n      if (this._token || this._connectData || this._config.name || this._config.version) {\n        msg.params = {};\n      }\n      if (this._token) {\n        msg.params.token = this._token;\n      }\n      if (this._connectData) {\n        msg.params.data = this._connectData;\n      }\n      if (this._config.name) {\n        msg.params.name = this._config.name;\n      }\n      if (this._config.version) {\n        msg.params.version = this._config.version;\n      }\n\n      let subs = {};\n      let hasSubs = false;\n      for (const channel in this._serverSubs) {\n        if (this._serverSubs.hasOwnProperty(channel) && this._serverSubs[channel].recoverable) {\n          hasSubs = true;\n          let sub = {\n            'recover': true\n          };\n          if (this._serverSubs[channel].seq || this._serverSubs[channel].gen) {\n            if (this._serverSubs[channel].seq) {\n              sub['seq'] = this._serverSubs[channel].seq;\n            }\n            if (this._serverSubs[channel].gen) {\n              sub['gen'] = this._serverSubs[channel].gen;\n            }\n          } else {\n            if (this._serverSubs[channel].offset) {\n              sub['offset'] = this._serverSubs[channel].offset;\n            }\n          }\n          if (this._serverSubs[channel].epoch) {\n            sub['epoch'] = this._serverSubs[channel].epoch;\n          }\n          subs[channel] = sub;\n        }\n      }\n      if (hasSubs) {\n        if (!msg.params) {msg.params = {};}\n        msg.params.subs = subs;\n      }\n\n      this._latencyStart = new Date();\n      this._call(msg).then(resolveCtx => {\n        this._connectResponse(this._decoder.decodeCommandResult(this._methodType.CONNECT, resolveCtx.result), hasSubs);\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        const err = rejectCtx.error;\n        if (err.code === 109) { // token expired.\n          this._refreshRequired = true;\n        }\n        this._disconnect('connect error', true);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    };\n\n    this._transport.onerror = error => {\n      this._debug('transport level error', error);\n    };\n\n    this._transport.onclose = closeEvent => {\n      this._transportClosed = true;\n      let reason = _errorConnectionClosed;\n      let needReconnect = true;\n\n      if (closeEvent && 'reason' in closeEvent && closeEvent.reason) {\n        try {\n          const advice = JSON.parse(closeEvent.reason);\n          this._debug('reason is an advice object', advice);\n          reason = advice.reason;\n          needReconnect = advice.reconnect;\n        } catch (e) {\n          reason = closeEvent.reason;\n          this._debug('reason is a plain string', reason);\n        }\n      }\n\n      // onTransportClose callback should be executed every time transport was closed.\n      // This can be helpful to catch failed connection events (because our disconnect\n      // event only called once and every future attempts to connect do not fire disconnect\n      // event again).\n      if (this._config.onTransportClose !== null) {\n        this._config.onTransportClose({\n          event: closeEvent,\n          reason: reason,\n          reconnect: needReconnect\n        });\n      }\n\n      this._disconnect(reason, needReconnect);\n\n      if (this._reconnect === true) {\n        this._reconnecting = true;\n        const interval = this._getRetryInterval();\n\n        this._debug('reconnect after ' + interval + ' milliseconds');\n        setTimeout(() => {\n          if (this._reconnect === true) {\n            if (this._refreshRequired) {\n              this._refresh();\n            } else {\n              this._connect();\n            }\n          }\n        }, interval);\n      }\n    };\n\n    this._transport.onmessage = event => {\n      this._dataReceived(event.data);\n    };\n  };\n\n  rpc(data) {\n    return this._rpc('', data);\n  }\n\n  namedRPC(method, data) {\n    return this._rpc(method, data);\n  }\n\n  _rpc(method, data) {\n    let params = {\n      data: data\n    };\n    if (method !== '') {\n      params.method = method;\n    };\n    const msg = {\n      method: this._methodType.RPC,\n      params: params\n    };\n    return this._methodCall(msg, function (result) {\n      return result;\n    });\n  }\n\n  send(data) {\n    const msg = {\n      method: this._methodType.SEND,\n      params: {\n        data: data\n      }\n    };\n\n    if (!this.isConnected()) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    }\n\n    const sent = this._transportSend([msg]); // can send async message to server without id set\n    if (!sent) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    };\n    return Promise.resolve({});\n  }\n\n  _getHistoryParams(channel, options) {\n    let params = {\n      channel: channel\n    };\n    if (options !== undefined) {\n      if (options.since) {\n        params['use_since'] = true;\n        if (options.since.offset) {\n          params['offset'] = options.since.offset;\n        }\n        if (options.since.epoch) {\n          params['epoch'] = options.since.epoch;\n        }\n      };\n      if (options.limit !== undefined) {\n        params['use_limit'] = true;\n        params['limit'] = options.limit;\n      }\n    };\n    return params;\n  }\n\n  _methodCall(msg, resultCB) {\n    if (!this.isConnected()) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    }\n    return new Promise((resolve, reject) => {\n      this._call(msg).then(resolveCtx => {\n        resolve(resultCB(this._decoder.decodeCommandResult(msg.method, resolveCtx.result)));\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        reject(rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    });\n  }\n\n  publish(channel, data) {\n    const msg = {\n      method: this._methodType.PUBLISH,\n      params: {\n        channel: channel,\n        data: data\n      }\n    };\n    return this._methodCall(msg, function (result) {\n      return {};\n    });\n  }\n\n  history(channel, options) {\n    const params = this._getHistoryParams(channel, options);\n    const msg = {\n      method: this._methodType.HISTORY,\n      params: params\n    };\n    return this._methodCall(msg, function (result) {\n      return result;\n    });\n  }\n\n  presence(channel) {\n    const msg = {\n      method: this._methodType.PRESENCE,\n      params: {\n        channel: channel\n      }\n    };\n    return this._methodCall(msg, function (result) {\n      return result;\n    });\n  }\n\n  presenceStats(channel) {\n    const msg = {\n      method: this._methodType.PRESENCE_STATS,\n      params: {\n        channel: channel\n      }\n    };\n    return this._methodCall(msg, function (result) {\n      return result;\n    });\n  }\n\n  _dataReceived(data) {\n    const replies = this._decoder.decodeReplies(data);\n    // we have to guarantee order of events in replies processing - i.e. start processing\n    // next reply only when we finished processing of current one. Without syncing things in\n    // this way we could get wrong publication events order as reply promises resolve\n    // on next loop tick so for loop continues before we finished emitting all reply events.\n    this._dispatchPromise = this._dispatchPromise.then(() => {\n      let finishDispatch;\n      this._dispatchPromise = new Promise(resolve =>{\n        finishDispatch = resolve;\n      });\n      this._dispatchSynchronized(replies, finishDispatch);\n    });\n    this._restartPing();\n  }\n\n  _dispatchSynchronized(replies, finishDispatch) {\n    let p = Promise.resolve();\n    for (const i in replies) {\n      if (replies.hasOwnProperty(i)) {\n        p = p.then(() => {\n          return this._dispatchReply(replies[i]);\n        });\n      }\n    }\n    p = p.then(() => {\n      finishDispatch();\n    });\n  }\n\n  _dispatchReply(reply) {\n    var next;\n    const p = new Promise(resolve =>{\n      next = resolve;\n    });\n\n    if (reply === undefined || reply === null) {\n      this._debug('dispatch: got undefined or null reply');\n      next();\n      return p;\n    }\n\n    const id = reply.id;\n\n    if (id && id > 0) {\n      this._handleReply(reply, next);\n    } else {\n      this._handlePush(reply.result, next);\n    }\n\n    return p;\n  };\n\n  _call(msg) {\n    return new Promise((resolve, reject) => {\n      const id = this._addMessage(msg);\n      this._registerCall(id, resolve, reject);\n    });\n  }\n\n  _connect() {\n    if (this.isConnected()) {\n      this._debug('connect called when already connected');\n      return;\n    }\n    if (this._status === 'connecting') {\n      return;\n    }\n\n    this._debug('start connecting');\n    this._setStatus('connecting');\n    this._clientID = null;\n    this._reconnect = true;\n    this._setupTransport();\n  };\n\n  _disconnect(reason, shouldReconnect) {\n\n    const reconnect = shouldReconnect || false;\n    if (reconnect === false) {\n      this._reconnect = false;\n    }\n\n    if (this._isDisconnected()) {\n      if (!reconnect) {\n        this._clearConnectedState(reconnect);\n      }\n      return;\n    }\n\n    this._clearConnectedState(reconnect);\n\n    this._debug('disconnected:', reason, shouldReconnect);\n    this._setStatus('disconnected');\n\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    if (this._reconnecting === false) {\n      // fire unsubscribe events for server side subs.\n      for (const channel in this._serverSubs) {\n        if (this._serverSubs.hasOwnProperty(channel)) {\n          this.emit('unsubscribe', {channel: channel});\n        }\n      }\n      this.emit('disconnect', {\n        reason: reason,\n        reconnect: reconnect\n      });\n    }\n\n    if (reconnect === false) {\n      this._subs = {};\n      this._serverSubs = {};\n    }\n\n    if (!this._transportClosed) {\n      this._transport.close();\n    }\n  };\n\n  _refreshFailed() {\n    this._numRefreshFailed = 0;\n    if (!this._isDisconnected()) {\n      this._disconnect('refresh failed', false);\n    }\n    if (this._config.onRefreshFailed !== null) {\n      this._config.onRefreshFailed();\n    }\n  };\n\n  _refresh() {\n    // ask application for new connection token.\n    this._debug('refresh token');\n\n    if (this._config.refreshAttempts === 0) {\n      this._debug('refresh attempts set to 0, do not send refresh request at all');\n      this._refreshFailed();\n      return;\n    }\n\n    if (this._refreshTimeout !== null) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n\n    const clientID = this._clientID;\n    const xhrID = this._newXHRID();\n\n    const cb = (resp) => {\n      if (xhrID in this._xhrs) {\n        delete this._xhrs[xhrID];\n      }\n      if (this._clientID !== clientID) {\n        return;\n      }\n      if (resp.error || resp.status !== 200) {\n        // We don't perform any connection status related actions here as we are\n        // relying on server that must close connection eventually.\n        if (resp.error) {\n          this._debug('error refreshing connection token', resp.error);\n        } else {\n          this._debug('error refreshing connection token: wrong status code', resp.status);\n        }\n        this._numRefreshFailed++;\n        if (this._refreshTimeout !== null) {\n          clearTimeout(this._refreshTimeout);\n          this._refreshTimeout = null;\n        }\n        if (this._config.refreshAttempts !== null && this._numRefreshFailed >= this._config.refreshAttempts) {\n          this._refreshFailed();\n          return;\n        }\n        const jitter = Math.round(Math.random() * 1000 * Math.max(this._numRefreshFailed, 20));\n        const interval = this._config.refreshInterval + jitter;\n        this._refreshTimeout = setTimeout(() => this._refresh(), interval);\n        return;\n      }\n      this._numRefreshFailed = 0;\n      this._token = resp.data.token;\n      if (!this._token) {\n        this._refreshFailed();\n        return;\n      }\n      if (this._isDisconnected() && this._reconnect) {\n        this._debug('token refreshed, connect from scratch');\n        this._connect();\n      } else {\n        this._debug('send refreshed token');\n        const msg = {\n          method: this._methodType.REFRESH,\n          params: {\n            token: this._token\n          }\n        };\n        this._call(msg).then(resolveCtx => {\n          this._refreshResponse(this._decoder.decodeCommandResult(this._methodType.REFRESH, resolveCtx.result));\n          if (resolveCtx.next) {\n            resolveCtx.next();\n          }\n        }, rejectCtx => {\n          this._refreshError(rejectCtx.error);\n          if (rejectCtx.next) {\n            rejectCtx.next();\n          }\n        });\n      }\n    };\n\n    if (this._config.onRefresh !== null) {\n      const context = {};\n      this._config.onRefresh(context, cb);\n    } else {\n      const xhr = this._ajax(\n        this._config.refreshEndpoint,\n        this._config.refreshParams,\n        this._config.refreshHeaders,\n        this._config.refreshData,\n        cb\n      );\n      this._xhrs[xhrID] = xhr;\n    }\n  };\n\n  _refreshError(err) {\n    this._debug('refresh error', err);\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    const interval = this._config.refreshInterval + Math.round(Math.random() * 1000);\n    this._refreshTimeout = setTimeout(() => this._refresh(), interval);\n  }\n\n  _refreshResponse(result) {\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    if (result.expires) {\n      this._clientID = result.client;\n      this._refreshTimeout = setTimeout(() => this._refresh(), this._getTTLMilliseconds(result.ttl));\n    }\n  };\n\n  _newXHRID() {\n    this._xhrID++;\n    return this._xhrID;\n  }\n\n  _subRefresh(channel) {\n    this._debug('refresh subscription token for channel', channel);\n\n    if (this._subRefreshTimeouts[channel] !== undefined) {\n      this._clearSubRefreshTimeout(channel);\n    } else {\n      return;\n    }\n\n    const clientID = this._clientID;\n    const xhrID = this._newXHRID();\n\n    const cb = (resp) => {\n      if (xhrID in this._xhrs) {\n        delete this._xhrs[xhrID];\n      }\n      if (resp.error || resp.status !== 200 || this._clientID !== clientID) {\n        return;\n      }\n      let channelsData = {};\n      if (resp.data.channels) {\n        for (const i in resp.data.channels) {\n          const channelData = resp.data.channels[i];\n          if (!channelData.channel) {\n            continue;\n          }\n          channelsData[channelData.channel] = channelData.token;\n        }\n      }\n\n      const token = channelsData[channel];\n      if (!token) {\n        return;\n      }\n      const msg = {\n        method: this._methodType.SUB_REFRESH,\n        params: {\n          channel: channel,\n          token: token\n        }\n      };\n\n      const sub = this._getSub(channel);\n      if (sub === null) {\n        return;\n      }\n\n      this._call(msg).then(resolveCtx => {\n        this._subRefreshResponse(\n          channel,\n          this._decoder.decodeCommandResult(this._methodType.SUB_REFRESH, resolveCtx.result)\n        );\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        this._subRefreshError(channel, rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    };\n\n    const data = {\n      client: this._clientID,\n      channels: [channel]\n    };\n\n    if (this._config.onPrivateSubscribe !== null) {\n      this._config.onPrivateSubscribe({\n        data: data\n      }, cb);\n    } else {\n      const xhr = this._ajax(\n        this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n      this._xhrs[xhrID] = xhr;\n    }\n  };\n\n  _clearSubRefreshTimeout(channel) {\n    if (this._subRefreshTimeouts[channel] !== undefined) {\n      clearTimeout(this._subRefreshTimeouts[channel]);\n      delete this._subRefreshTimeouts[channel];\n    }\n  }\n\n  _subRefreshError(channel, err) {\n    this._debug('subscription refresh error', channel, err);\n    this._clearSubRefreshTimeout(channel);\n    const sub = this._getSub(channel);\n    if (sub === null) {\n      return;\n    }\n    const jitter = Math.round(Math.random() * 1000);\n    let subRefreshTimeout = setTimeout(() => this._subRefresh(channel), this._config.subRefreshInterval + jitter);\n    this._subRefreshTimeouts[channel] = subRefreshTimeout;\n    return;\n  }\n\n  _subRefreshResponse(channel, result) {\n    this._debug('subscription refresh success', channel);\n    this._clearSubRefreshTimeout(channel);\n    const sub = this._getSub(channel);\n    if (sub === null) {\n      return;\n    }\n    if (result.expires === true) {\n      let subRefreshTimeout = setTimeout(() => this._subRefresh(channel), this._getTTLMilliseconds(result.ttl));\n      this._subRefreshTimeouts[channel] = subRefreshTimeout;\n    }\n    return;\n  };\n\n  _subscribe(sub, isResubscribe) {\n    this._debug('subscribing on', sub.channel);\n    const channel = sub.channel;\n\n    if (!(channel in this._subs)) {\n      this._subs[channel] = sub;\n    }\n\n    if (!this.isConnected()) {\n      // subscribe will be called later\n      sub._setNew();\n      return;\n    }\n\n    sub._setSubscribing(isResubscribe);\n\n    const msg = {\n      method: this._methodType.SUBSCRIBE,\n      params: {\n        channel: channel\n      }\n    };\n\n    // If channel name does not start with privateChannelPrefix - then we\n    // can just send subscription message to Centrifuge. If channel name\n    // starts with privateChannelPrefix - then this is a private channel\n    // and we should ask web application backend for permission first.\n    if (startsWith(channel, this._config.privateChannelPrefix)) {\n      // private channel.\n      if (this._isSubscribeBatching) {\n        this._privateChannels[channel] = true;\n      } else {\n        this.startSubscribeBatching();\n        this._subscribe(sub);\n        this.stopSubscribeBatching();\n      }\n    } else {\n      const recover = sub._needRecover();\n\n      if (recover === true) {\n        msg.params.recover = true;\n        const seq = this._getLastSeq(channel);\n        const gen = this._getLastGen(channel);\n        if (seq || gen) {\n          if (seq) {\n            msg.params.seq = seq;\n          }\n          if (gen) {\n            msg.params.gen = gen;\n          }\n        } else {\n          const offset = this._getLastOffset(channel);\n          if (offset) {\n            msg.params.offset = offset;\n          }\n        }\n        const epoch = this._getLastEpoch(channel);\n        if (epoch) {\n          msg.params.epoch = epoch;\n        }\n      }\n\n      this._call(msg).then(resolveCtx => {\n        this._subscribeResponse(\n          channel,\n          recover,\n          this._decoder.decodeCommandResult(this._methodType.SUBSCRIBE, resolveCtx.result)\n        );\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        this._subscribeError(channel, rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    }\n  };\n\n  _unsubscribe(sub) {\n    delete this._subs[sub.channel];\n    delete this._lastOffset[sub.channel];\n    delete this._lastSeq[sub.channel];\n    delete this._lastGen[sub.channel];\n    if (this.isConnected()) {\n      // No need to unsubscribe in disconnected state - i.e. client already unsubscribed.\n      this._addMessage({\n        method: this._methodType.UNSUBSCRIBE,\n        params: {\n          channel: sub.channel\n        }\n      });\n    }\n  };\n\n  _getTTLMilliseconds(ttl) {\n    // https://stackoverflow.com/questions/12633405/what-is-the-maximum-delay-for-setinterval\n    return Math.min(ttl * 1000, 2147483647);\n  }\n\n  getSub(channel) {\n    return this._getSub(channel);\n  }\n\n  _getSub(channel) {\n    const sub = this._subs[channel];\n    if (!sub) {\n      return null;\n    }\n    return sub;\n  };\n\n  _isServerSub(channel) {\n    return this._serverSubs[channel] !== undefined;\n  };\n\n  _connectResponse(result, isRecover) {\n    const wasReconnecting = this._reconnecting;\n    this._reconnecting = false;\n    this._resetRetry();\n    this._refreshRequired = false;\n\n    if (this.isConnected()) {\n      return;\n    }\n\n    if (this._latencyStart !== null) {\n      this._latency = (new Date()).getTime() - this._latencyStart.getTime();\n      this._latencyStart = null;\n    }\n\n    this._clientID = result.client;\n    this._setStatus('connected');\n\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n    }\n\n    if (result.expires) {\n      this._refreshTimeout = setTimeout(() => this._refresh(), this._getTTLMilliseconds(result.ttl));\n    }\n\n    this.startBatching();\n    this.startSubscribeBatching();\n    for (const channel in this._subs) {\n      if (this._subs.hasOwnProperty(channel)) {\n        const sub = this._subs[channel];\n        if (sub._shouldResubscribe()) {\n          this._subscribe(sub, wasReconnecting);\n        }\n      }\n    }\n    this.stopSubscribeBatching();\n    this.stopBatching();\n\n    this._startPing();\n\n    const ctx = {\n      client: result.client,\n      transport: this._transportName,\n      latency: this._latency\n    };\n    if (result.data) {\n      ctx.data = result.data;\n    }\n\n    this.emit('connect', ctx);\n\n    if (result.subs) {\n      this._processServerSubs(result.subs);\n    }\n  };\n\n  _processServerSubs(subs) {\n    for (const channel in subs) {\n      if (subs.hasOwnProperty(channel)) {\n        const sub = subs[channel];\n        const isResubscribe = this._serverSubs[channel] !== undefined;\n        let subCtx = {channel: channel, isResubscribe: isResubscribe};\n        subCtx = this._expandSubscribeContext(subCtx, sub);\n        this.emit('subscribe', subCtx);\n      }\n    }\n    for (const channel in subs) {\n      if (subs.hasOwnProperty(channel)) {\n        const sub = subs[channel];\n        if (sub.recovered) {\n          let pubs = sub.publications;\n          if (pubs && pubs.length > 0) {\n\n            // handle legacy order.\n            // TODO: remove as soon as Centrifuge v1 released.\n            if (pubs.length > 1 && (!pubs[0].offset || pubs[0].offset > pubs[1].offset)) {\n              pubs = pubs.reverse();\n            }\n\n            for (let i in pubs) {\n              if (pubs.hasOwnProperty(i)) {\n                this._handlePublication(channel, pubs[i]);\n              }\n            }\n          }\n        }\n        this._serverSubs[channel] = {\n          'seq': sub.seq,\n          'gen': sub.gen,\n          'offset': sub.offset,\n          'epoch': sub.epoch,\n          'recoverable': sub.recoverable\n        };\n      }\n    }\n  };\n\n  _stopPing() {\n    if (this._pongTimeout !== null) {\n      clearTimeout(this._pongTimeout);\n      this._pongTimeout = null;\n    }\n    if (this._pingTimeout !== null) {\n      clearTimeout(this._pingTimeout);\n      this._pingTimeout = null;\n    }\n  };\n\n  _startPing() {\n    if (this._config.ping !== true || this._config.pingInterval <= 0) {\n      return;\n    }\n    if (!this.isConnected()) {\n      return;\n    }\n\n    this._pingTimeout = setTimeout(() => {\n      if (!this.isConnected()) {\n        this._stopPing();\n        return;\n      }\n      this.ping();\n      this._pongTimeout = setTimeout(() => {\n        this._disconnect('no ping', true);\n      }, this._config.pongWaitTimeout);\n    }, this._config.pingInterval);\n  };\n\n  _restartPing() {\n    this._stopPing();\n    this._startPing();\n  };\n\n  _subscribeError(channel, error) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    if (!sub._isSubscribing()) {\n      return;\n    }\n    if (error.code === 0 && error.message === _errorTimeout) { // client side timeout.\n      this._disconnect('timeout', true);\n      return;\n    }\n    sub._setSubscribeError(error);\n  };\n\n  _expandSubscribeContext(ctx, result) {\n    let recovered = false;\n    if ('recovered' in result) {\n      recovered = result.recovered;\n    }\n    ctx.recovered = recovered;\n\n    let positioned = false;\n    if ('positioned' in result) {\n      positioned = result.positioned;\n    }\n    let epoch = '';\n    if ('epoch' in result) {\n      epoch = result.epoch;\n    }\n    let offset = 0;\n    if ('offset' in result) {\n      offset = result.offset;\n    }\n    if (positioned) {\n      ctx.streamPosition = {\n        'offset': offset,\n        'epoch': epoch\n      };\n    };\n    return ctx;\n  }\n\n  _subscribeResponse(channel, isRecover, result) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    if (!sub._isSubscribing()) {\n      return;\n    }\n    sub._setSubscribeSuccess(result);\n\n    let pubs = result.publications;\n    if (pubs && pubs.length > 0) {\n      if (pubs.length >= 2 && !pubs[0].offset && !pubs[1].offset) {\n        // handle legacy order.\n        pubs = pubs.reverse();\n      }\n      for (let i in pubs) {\n        if (pubs.hasOwnProperty(i)) {\n          this._handlePublication(channel, pubs[i]);\n        }\n      }\n    }\n\n    if (result.recoverable && (!isRecover || !result.recovered)) {\n      this._lastSeq[channel] = result.seq || 0;\n      this._lastGen[channel] = result.gen || 0;\n      this._lastOffset[channel] = result.offset || 0;\n    }\n\n    this._lastEpoch[channel] = result.epoch || '';\n\n    if (result.recoverable) {\n      sub._recoverable = true;\n    }\n\n    if (result.expires === true) {\n      let subRefreshTimeout = setTimeout(() => this._subRefresh(channel), this._getTTLMilliseconds(result.ttl));\n      this._subRefreshTimeouts[channel] = subRefreshTimeout;\n    }\n  };\n\n  _handleReply(reply, next) {\n    const id = reply.id;\n    const result = reply.result;\n\n    if (!(id in this._callbacks)) {\n      next();\n      return;\n    }\n    const callbacks = this._callbacks[id];\n    clearTimeout(this._callbacks[id].timeout);\n    delete this._callbacks[id];\n\n    if (!errorExists(reply)) {\n      const callback = callbacks.callback;\n      if (!callback) {\n        return;\n      }\n      callback({result, next});\n    } else {\n      const errback = callbacks.errback;\n      if (!errback) {\n        next();\n        return;\n      }\n      const error = reply.error;\n      errback({error, next});\n    }\n  }\n\n  _handleJoin(channel, join) {\n    const ctx = {'info': join.info};\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        ctx.channel = channel;\n        this.emit('join', ctx);\n      }\n      return;\n    }\n    sub.emit('join', ctx);\n  };\n\n  _handleLeave(channel, leave) {\n    const ctx = {'info': leave.info};\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        ctx.channel = channel;\n        this.emit('leave', ctx);\n      }\n      return;\n    }\n    sub.emit('leave', ctx);\n  };\n\n  _handleUnsub(channel, unsub) {\n    const ctx = {};\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        delete this._serverSubs[channel];\n        ctx.channel = channel;\n        this.emit('unsubscribe', ctx);\n      }\n      return;\n    }\n    sub.unsubscribe();\n    if (unsub.resubscribe === true) {\n      sub.subscribe();\n    }\n  };\n\n  _handleSub(channel, sub) {\n    this._serverSubs[channel] = {\n      'seq': sub.seq,\n      'gen': sub.gen,\n      'offset': sub.offset,\n      'epoch': sub.epoch,\n      'recoverable': sub.recoverable\n    };\n    let ctx = {'channel': channel, isResubscribe: false};\n    ctx = this._expandSubscribeContext(ctx, sub);\n    this.emit('subscribe', ctx);\n  };\n\n  _handlePublication(channel, pub) {\n    const sub = this._getSub(channel);\n    const ctx = {\n      'data': pub.data,\n      'seq': pub.seq,\n      'gen': pub.gen,\n      'offset': pub.offset\n    };\n    if (pub.info) {\n      ctx.info = pub.info;\n    }\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        if (pub.seq !== undefined) {\n          this._serverSubs[channel].seq = pub.seq;\n        }\n        if (pub.gen !== undefined) {\n          this._serverSubs[channel].gen = pub.gen;\n        }\n        if (pub.offset !== undefined) {\n          this._serverSubs[channel].offset = pub.offset;\n        }\n        ctx.channel = channel;\n        this.emit('publish', ctx);\n      }\n      return;\n    }\n    if (pub.seq !== undefined) {\n      this._lastSeq[channel] = pub.seq;\n    }\n    if (pub.gen !== undefined) {\n      this._lastGen[channel] = pub.gen;\n    }\n    if (pub.offset !== undefined) {\n      this._lastOffset[channel] = pub.offset;\n    }\n    sub.emit('publish', ctx);\n  };\n\n  _handleMessage(message) {\n    this.emit('message', message.data);\n  };\n\n  _handlePush(data, next) {\n    const push = this._decoder.decodePush(data);\n    let type = 0;\n    if ('type' in push) {\n      type = push['type'];\n    }\n    const channel = push.channel;\n\n    if (type === this._pushType.PUBLICATION) {\n      const pub = this._decoder.decodePushData(this._pushType.PUBLICATION, push.data);\n      this._handlePublication(channel, pub);\n    } else if (type === this._pushType.MESSAGE) {\n      const message = this._decoder.decodePushData(this._pushType.MESSAGE, push.data);\n      this._handleMessage(message);\n    } else if (type === this._pushType.JOIN) {\n      const join = this._decoder.decodePushData(this._pushType.JOIN, push.data);\n      this._handleJoin(channel, join);\n    } else if (type === this._pushType.LEAVE) {\n      const leave = this._decoder.decodePushData(this._pushType.LEAVE, push.data);\n      this._handleLeave(channel, leave);\n    } else if (type === this._pushType.UNSUB) {\n      const unsub = this._decoder.decodePushData(this._pushType.UNSUB, push.data);\n      this._handleUnsub(channel, unsub);\n    } else if (type === this._pushType.SUB) {\n      const sub = this._decoder.decodePushData(this._pushType.SUB, push.data);\n      this._handleSub(channel, sub);\n    }\n    next();\n  }\n\n  _flush() {\n    const messages = this._messages.slice(0);\n    this._messages = [];\n    this._transportSend(messages);\n  };\n\n  _ping() {\n    const msg = {\n      method: this._methodType.PING\n    };\n    this._call(msg).then(resolveCtx => {\n      this._pingResponse(this._decoder.decodeCommandResult(this._methodType.PING, resolveCtx.result));\n      if (resolveCtx.next) {\n        resolveCtx.next();\n      }\n    }, rejectCtx => {\n      this._debug('ping error', rejectCtx.error);\n      if (rejectCtx.next) {\n        rejectCtx.next();\n      }\n    });\n  };\n\n  _pingResponse(result) {\n    if (!this.isConnected()) {\n      return;\n    }\n    this._stopPing();\n    this._startPing();\n  }\n\n  _getLastSeq(channel) {\n    const lastSeq = this._lastSeq[channel];\n    if (lastSeq) {\n      return lastSeq;\n    }\n    return 0;\n  };\n\n  _getLastOffset(channel) {\n    const lastOffset = this._lastOffset[channel];\n    if (lastOffset) {\n      return lastOffset;\n    }\n    return 0;\n  };\n\n  _getLastGen(channel) {\n    const lastGen = this._lastGen[channel];\n    if (lastGen) {\n      return lastGen;\n    }\n    return 0;\n  };\n\n  _getLastEpoch(channel) {\n    const lastEpoch = this._lastEpoch[channel];\n    if (lastEpoch) {\n      return lastEpoch;\n    }\n    return '';\n  };\n\n  _createErrorObject(message, code) {\n    const errObject = {\n      message: message,\n      code: code || 0\n    };\n\n    return errObject;\n  };\n\n  _registerCall(id, callback, errback) {\n    this._callbacks[id] = {\n      callback: callback,\n      errback: errback,\n      timeout: null\n    };\n    this._callbacks[id].timeout = setTimeout(() => {\n      delete this._callbacks[id];\n      if (isFunction(errback)) {\n        errback({error: this._createErrorObject(_errorTimeout)});\n      }\n    }, this._config.timeout);\n  };\n\n  _addMessage(message) {\n    let id = this._nextMessageId();\n    message.id = id;\n    if (this._isBatching === true) {\n      this._messages.push(message);\n    } else {\n      this._transportSend([message]);\n    }\n    return id;\n  };\n\n  isConnected() {\n    return this._isConnected();\n  }\n\n  connect() {\n    this._connect();\n  };\n\n  disconnect() {\n    this._disconnect('client', false);\n  };\n\n  ping() {\n    return this._ping();\n  }\n\n  startBatching() {\n    // start collecting messages without sending them to Centrifuge until flush\n    // method called\n    this._isBatching = true;\n  };\n\n  stopBatching() {\n    this._isBatching = false;\n    this._flush();\n  };\n\n  startSubscribeBatching() {\n    // start collecting private channels to create bulk authentication\n    // request to subscribeEndpoint when stopSubscribeBatching will be called\n    this._isSubscribeBatching = true;\n  };\n\n  stopSubscribeBatching() {\n    // create request to subscribeEndpoint with collected private channels\n    // to ask if this client can subscribe on each channel\n    this._isSubscribeBatching = false;\n    const authChannels = this._privateChannels;\n    this._privateChannels = {};\n\n    const channels = [];\n\n    for (const channel in authChannels) {\n      if (authChannels.hasOwnProperty(channel)) {\n        const sub = this._getSub(channel);\n        if (!sub) {\n          continue;\n        }\n        channels.push(channel);\n      }\n    }\n\n    if (channels.length === 0) {\n      this._debug('no private channels found, no need to make request');\n      return;\n    }\n\n    const data = {\n      client: this._clientID,\n      channels: channels\n    };\n\n    const clientID = this._clientID;\n    const xhrID = this._newXHRID();\n\n    const cb = (resp) => {\n      if (xhrID in this._xhrs) {\n        delete this._xhrs[xhrID];\n      }\n      if (this._clientID !== clientID) {\n        return;\n      }\n      if (resp.error || resp.status !== 200) {\n        this._debug('authorization request failed');\n        for (const i in channels) {\n          if (channels.hasOwnProperty(i)) {\n            const channel = channels[i];\n            this._subscribeError(channel, this._createErrorObject('authorization request failed'));\n          }\n        }\n        return;\n      }\n\n      let channelsData = {};\n      if (resp.data.channels) {\n        for (const i in resp.data.channels) {\n          const channelData = resp.data.channels[i];\n          if (!channelData.channel) {\n            continue;\n          }\n          channelsData[channelData.channel] = channelData.token;\n        }\n      }\n\n      // try to send all subscriptions in one request.\n      let batch = false;\n\n      if (!this._isBatching) {\n        this.startBatching();\n        batch = true;\n      }\n\n      for (const i in channels) {\n        if (channels.hasOwnProperty(i)) {\n          const channel = channels[i];\n          const token = channelsData[channel];\n\n          if (!token) {\n            // subscription:error\n            this._subscribeError(channel, this._createErrorObject('permission denied', 103));\n            continue;\n          } else {\n            const msg = {\n              method: this._methodType.SUBSCRIBE,\n              params: {\n                channel: channel,\n                token: token\n              }\n            };\n\n            const sub = this._getSub(channel);\n            if (sub === null) {\n              continue;\n            }\n\n            const recover = sub._needRecover();\n\n            if (recover === true) {\n              msg.params.recover = true;\n              const seq = this._getLastSeq(channel);\n              const gen = this._getLastGen(channel);\n              if (seq || gen) {\n                if (seq) {\n                  msg.params.seq = seq;\n                }\n                if (gen) {\n                  msg.params.gen = gen;\n                }\n              } else {\n                const offset = this._getLastOffset(channel);\n                if (offset) {\n                  msg.params.offset = offset;\n                }\n              }\n              const epoch = this._getLastEpoch(channel);\n              if (epoch) {\n                msg.params.epoch = epoch;\n              }\n            }\n            this._call(msg).then(resolveCtx => {\n              this._subscribeResponse(\n                channel,\n                recover,\n                this._decoder.decodeCommandResult(this._methodType.SUBSCRIBE, resolveCtx.result)\n              );\n              if (resolveCtx.next) {\n                resolveCtx.next();\n              }\n            }, rejectCtx => {\n              this._subscribeError(channel, rejectCtx.error);\n              if (rejectCtx.next) {\n                rejectCtx.next();\n              }\n            });\n          }\n        }\n      }\n\n      if (batch) {\n        this.stopBatching();\n      }\n\n    };\n\n    if (this._config.onPrivateSubscribe !== null) {\n      this._config.onPrivateSubscribe({\n        data: data\n      }, cb);\n    } else {\n      const xhr = this._ajax(\n        this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n      this._xhrs[xhrID] = xhr;\n    }\n  };\n\n  subscribe(channel, events) {\n    const currentSub = this._getSub(channel);\n    if (currentSub !== null) {\n      currentSub._setEvents(events);\n      if (currentSub._isUnsubscribed()) {\n        currentSub.subscribe();\n      }\n      return currentSub;\n    }\n    const sub = new Subscription(this, channel, events);\n    this._subs[channel] = sub;\n    sub.subscribe();\n    return sub;\n  };\n}\n","import {Centrifuge} from './centrifuge.js';\nexport default Centrifuge;\n","export const JsonMethodType = {\n  CONNECT: 0,\n  SUBSCRIBE: 1,\n  UNSUBSCRIBE: 2,\n  PUBLISH: 3,\n  PRESENCE: 4,\n  PRESENCE_STATS: 5,\n  HISTORY: 6,\n  PING: 7,\n  SEND: 8,\n  RPC: 9,\n  REFRESH: 10,\n  SUB_REFRESH: 11\n};\n\nexport const JsonPushType = {\n  PUBLICATION: 0,\n  JOIN: 1,\n  LEAVE: 2,\n  UNSUB: 3,\n  MESSAGE: 4,\n  SUB: 5\n};\n\nexport class JsonEncoder {\n  encodeCommands(commands) {\n    const encodedCommands = [];\n    for (const i in commands) {\n      if (commands.hasOwnProperty(i)) {\n        encodedCommands.push(JSON.stringify(commands[i]));\n      }\n    }\n    return encodedCommands.join('\\n');\n  }\n}\n\nexport class JsonDecoder {\n  decodeReplies(data) {\n    const replies = [];\n    const encodedReplies = data.split('\\n');\n    for (const i in encodedReplies) {\n      if (encodedReplies.hasOwnProperty(i)) {\n        if (!encodedReplies[i]) {\n          continue;\n        }\n        const reply = JSON.parse(encodedReplies[i]);\n        replies.push(reply);\n      }\n    }\n    return replies;\n  }\n\n  decodeCommandResult(methodType, data) {\n    return data;\n  }\n\n  decodePush(data) {\n    return data;\n  }\n\n  decodePushData(pushType, data) {\n    return data;\n  }\n}\n\n","import EventEmitter from 'events';\n\nimport {\n  isFunction\n} from './utils';\n\nconst _STATE_NEW = 0;\nconst _STATE_SUBSCRIBING = 1;\nconst _STATE_SUCCESS = 2;\nconst _STATE_ERROR = 3;\nconst _STATE_UNSUBSCRIBED = 4;\n\nexport default class Subscription extends EventEmitter {\n  constructor(centrifuge, channel, events) {\n    super();\n    this.channel = channel;\n    this._centrifuge = centrifuge;\n    this._status = _STATE_NEW;\n    this._error = null;\n    this._isResubscribe = false;\n    this._ready = false;\n    this._subscriptionPromise = null;\n    this._noResubscribe = false;\n    this._recoverable = false;\n    this._recover = false;\n    this._setEvents(events);\n    this._initializePromise();\n    this._promises = {};\n    this._promiseId = 0;\n    this.on('error', function (errContext) {\n      this._centrifuge._debug('subscription error', errContext);\n    });\n  }\n\n  _nextPromiseId() {\n    return ++this._promiseId;\n  }\n\n  _initializePromise() {\n    // this helps us to wait until subscription will successfully\n    // subscribe and call actions such as presence, history etc in\n    // synchronous way.\n    this._ready = false;\n\n    this._subscriptionPromise = new Promise((resolve, reject) => {\n      this._resolve = value => {\n        this._ready = true;\n        resolve(value);\n      };\n      this._reject = err => {\n        this._ready = true;\n        reject(err);\n      };\n    }).then(function () {}, function () {});\n  };\n\n  _needRecover() {\n    return this._recoverable === true && this._recover === true;\n  };\n\n  _setEvents(events) {\n    if (!events) {\n      return;\n    }\n    if (isFunction(events)) {\n      // events is just a function to handle publication received from channel.\n      this.on('publish', events);\n    } else if (Object.prototype.toString.call(events) === Object.prototype.toString.call({})) {\n      const knownEvents = ['publish', 'join', 'leave', 'unsubscribe', 'subscribe', 'error'];\n      for (let i = 0, l = knownEvents.length; i < l; i++) {\n        const ev = knownEvents[i];\n        if (ev in events) {\n          this.on(ev, events[ev]);\n        }\n      }\n    }\n  };\n\n  _isNew() {\n    return this._status === _STATE_NEW;\n  };\n\n  _isUnsubscribed() {\n    return this._status === _STATE_UNSUBSCRIBED;\n  };\n\n  _isSubscribing() {\n    return this._status === _STATE_SUBSCRIBING;\n  };\n\n  _isReady() {\n    return this._status === _STATE_SUCCESS || this._status === _STATE_ERROR;\n  };\n\n  _isSuccess() {\n    return this._status === _STATE_SUCCESS;\n  };\n\n  _isError() {\n    return this._status === _STATE_ERROR;\n  };\n\n  _setNew() {\n    this._status = _STATE_NEW;\n  };\n\n  _setSubscribing(isResubscribe) {\n    this._isResubscribe = isResubscribe || false;\n    if (this._ready === true) {\n      // new promise for this subscription\n      this._initializePromise();\n    }\n    this._status = _STATE_SUBSCRIBING;\n  };\n\n  _setSubscribeSuccess(subscribeResult) {\n    if (this._status === _STATE_SUCCESS) {\n      return;\n    }\n    this._status = _STATE_SUCCESS;\n    const successContext = this._getSubscribeSuccessContext(subscribeResult);\n    this._recover = false;\n    this.emit('subscribe', successContext);\n    this._resolve(successContext);\n    for (const id in this._promises) {\n      clearTimeout(this._promises[id].timeout);\n      this._promises[id].resolve();\n      delete this._promises[id];\n    }\n  };\n\n  _setSubscribeError(err) {\n    if (this._status === _STATE_ERROR) {\n      return;\n    }\n    this._status = _STATE_ERROR;\n    this._error = err;\n    const errContext = this._getSubscribeErrorContext();\n    this.emit('error', errContext);\n    this._reject(errContext);\n    for (const id in this._promises) {\n      clearTimeout(this._promises[id].timeout);\n      this._promises[id].reject(err);\n      delete this._promises[id];\n    }\n  };\n\n  _triggerUnsubscribe() {\n    this.emit('unsubscribe', {\n      channel: this.channel\n    });\n  };\n\n  _setUnsubscribed(noResubscribe) {\n    this._centrifuge._clearSubRefreshTimeout(this.channel);\n    if (this._status === _STATE_UNSUBSCRIBED) {\n      return;\n    }\n    const needTrigger = this._status === _STATE_SUCCESS;\n    this._status = _STATE_UNSUBSCRIBED;\n    if (noResubscribe === true) {\n      this._recover = false;\n      this._noResubscribe = true;\n      delete this._centrifuge._lastSeq[this.channel];\n      delete this._centrifuge._lastGen[this.channel];\n      delete this._centrifuge._lastEpoch[this.channel];\n    }\n    if (needTrigger) {\n      this._triggerUnsubscribe();\n    }\n  };\n\n  _shouldResubscribe() {\n    return !this._noResubscribe;\n  };\n\n  _getSubscribeSuccessContext(subscribeResult) {\n    let ctx = {\n      channel: this.channel,\n      isResubscribe: this._isResubscribe\n    };\n    if (subscribeResult) {\n      // subscribeResult not available when called from Subscription.ready method at the moment.\n      ctx = this._centrifuge._expandSubscribeContext(ctx, subscribeResult);\n    }\n    return ctx;\n  };\n\n  _getSubscribeErrorContext() {\n    const subscribeErrorContext = this._error;\n    subscribeErrorContext.channel = this.channel;\n    subscribeErrorContext.isResubscribe = this._isResubscribe;\n    return subscribeErrorContext;\n  };\n\n  ready(callback, errback) {\n    if (this._ready) {\n      if (this._isSuccess()) {\n        callback(this._getSubscribeSuccessContext());\n      } else {\n        errback(this._getSubscribeErrorContext());\n      }\n    }\n  };\n\n  subscribe() {\n    if (this._status === _STATE_SUCCESS) {\n      return;\n    }\n    this._noResubscribe = false;\n    this._centrifuge._subscribe(this);\n  };\n\n  unsubscribe() {\n    this._setUnsubscribed(true);\n    this._centrifuge._unsubscribe(this);\n  };\n\n  _methodCall(message, type) {\n    const methodCallPromise = new Promise((resolve, reject) => {\n      let subPromise;\n      if (this._isSuccess()) {\n        subPromise = Promise.resolve();\n      } else if (this._isError()) {\n        subPromise = Promise.reject(this._error);\n      } else {\n        subPromise = new Promise((res, rej) => {\n          const timeout = setTimeout(function () {\n            rej({'code': 0, 'message': 'timeout'});\n          }, this._centrifuge._config.timeout);\n          this._promises[this._nextPromiseId()] = {\n            timeout: timeout,\n            resolve: res,\n            reject: rej\n          };\n        });\n      }\n      subPromise.then(\n        () => {\n          return this._centrifuge._call(message).then(\n            resolveCtx => {\n              resolve(this._centrifuge._decoder.decodeCommandResult(type, resolveCtx.result));\n              if (resolveCtx.next) {\n                resolveCtx.next();\n              }\n            },\n            rejectCtx => {\n              reject(rejectCtx.error);\n              if (rejectCtx.next) {\n                rejectCtx.next();\n              }\n            }\n          );\n        },\n        error => {\n          reject(error);\n        }\n      );\n    });\n    return methodCallPromise;\n  }\n\n  publish(data) {\n    return this._methodCall({\n      method: this._centrifuge._methodType.PUBLISH,\n      params: {\n        channel: this.channel,\n        data: data\n      }\n    }, this._centrifuge._methodType.PUBLISH);\n  };\n\n  presence() {\n    return this._methodCall({\n      method: this._centrifuge._methodType.PRESENCE,\n      params: {\n        channel: this.channel\n      }\n    }, this._centrifuge._methodType.PRESENCE);\n  };\n\n  presenceStats() {\n    return this._methodCall({\n      method: this._centrifuge._methodType.PRESENCE_STATS,\n      params: {\n        channel: this.channel\n      }\n    }, this._centrifuge._methodType.PRESENCE_STATS);\n  };\n\n  history(options) {\n    const params = this._centrifuge._getHistoryParams(this.channel, options);\n    return this._methodCall({\n      method: this._centrifuge._methodType.HISTORY,\n      params: params\n    }, this._centrifuge._methodType.HISTORY);\n  };\n}\n","export function startsWith(value, prefix) {\n  return value.lastIndexOf(prefix, 0) === 0;\n};\n\nexport function isFunction(value) {\n  if (value === undefined || value === null) {\n    return false;\n  }\n  return typeof value === 'function';\n};\n\nexport function log(level, args) {\n  if (global.console) {\n    const logger = global.console[level];\n\n    if (isFunction(logger)) {\n      logger.apply(global.console, args);\n    }\n  }\n};\n\nexport function backoff(step, min, max) {\n  const jitter = 0.5 * Math.random();\n  const interval = Math.min(max, min * Math.pow(2, step + 1));\n\n  return Math.floor((1 - jitter) * interval);\n};\n\nexport function errorExists(data) {\n  return 'error' in data && data.error !== null;\n};\n\nexport function extend(a, b) {\n  for (const key in b) {\n    if (b.hasOwnProperty(key)) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function eventListener() {\n      if (errorListener !== undefined) {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n    var errorListener;\n\n    // Adding an error listener is not optional because\n    // if an error is thrown on an event emitter we cannot\n    // guarantee that the actual event we are waiting will\n    // be fired. The result could be a silent way to create\n    // memory or file descriptor leaks, which is something\n    // we should avoid.\n    if (name !== 'error') {\n      errorListener = function errorListener(err) {\n        emitter.removeListener(name, eventListener);\n        reject(err);\n      };\n\n      emitter.once('error', errorListener);\n    }\n\n    emitter.once(name, eventListener);\n  });\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(579);\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();"],"sourceRoot":""}