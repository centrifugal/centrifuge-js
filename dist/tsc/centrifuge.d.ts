/// <reference types="node" />
import EventEmitter from 'events';
import { Subscription } from './subscription';
export declare class Centrifuge extends EventEmitter {
    constructor(endpoint: any, options: any);
    newSubscription(channel: any, opts: any): Subscription;
    getSubscription(channel: any): any;
    removeSubscription(sub: any): void;
    subscriptions(): any;
    ready(timeout: any): Promise<unknown>;
    connect(): void;
    disconnect(): void;
    send(data: any): Promise<void>;
    rpc(method: any, data: any): Promise<unknown>;
    publish(channel: any, data: any): Promise<unknown>;
    history(channel: any, options: any): Promise<unknown>;
    presence(channel: any): Promise<unknown>;
    presenceStats(channel: any): Promise<unknown>;
    startBatching(): void;
    stopBatching(): void;
    _log(): void;
    _debug(): void;
    _setFormat(format: any): void;
    _formatOverride(_format: any): boolean;
    _configure(options: any): void;
    _setState(newState: any): boolean;
    _isDisconnected(): boolean;
    _isConnecting(): boolean;
    _isConnected(): boolean;
    _nextCommandId(): number;
    _getReconnectDelay(): number;
    _clearOutgoingRequests(): void;
    _clearConnectedState(): void;
    _handleWriteError(commands: any): void;
    _transportSendCommands(commands: any): boolean;
    _initializeTransport(): void;
    _sendConnect(): void;
    _startReconnecting(): void;
    _connectError(err: any): void;
    _constructConnectCommand(): {
        connect: {};
    };
    _getHistoryRequest(channel: any, options: any): {
        channel: any;
    };
    _methodCall(): Promise<unknown>;
    _callPromise(cmd: any, resultCB: any): Promise<unknown>;
    _dataReceived(data: any): void;
    _dispatchSynchronized(replies: any, finishDispatch: any): void;
    _dispatchReply(reply: any): Promise<unknown>;
    _call(cmd: any): Promise<unknown>;
    _callConnectFake(id: any): Promise<unknown>;
    _startConnecting(): void;
    _disconnect(code: any, reason: any, reconnect: any): void;
    _failUnauthorized(): void;
    _getToken(): any;
    _refresh(): void;
    _refreshError(err: any): void;
    _getRefreshRetryDelay(): number;
    _refreshResponse(result: any): void;
    _subscribe(sub: any): void;
    _sendSubscribe(sub: any, token: any): void;
    _sendSubRefresh(sub: any, token: any): void;
    _removeSubscription(sub: any): void;
    _unsubscribe(sub: any): void;
    _getSub(channel: any): any;
    _isServerSub(channel: any): boolean;
    _connectResponse(result: any): void;
    _processServerSubs(subs: any): void;
    _clearRefreshTimeout(): void;
    _clearReconnectTimeout(): void;
    _clearServerPingTimeout(): void;
    _waitServerPing(): void;
    _subscribeError(channel: any, error: any): void;
    _getSubscribeContext(channel: any, result: any): {
        channel: any;
        positioned: boolean;
        recoverable: boolean;
        wasRecovering: boolean;
        recovered: boolean;
    };
    _subscribeResponse(channel: any, result: any): void;
    _handleReply(reply: any, next: any): void;
    _handleJoin(channel: any, join: any): void;
    _handleLeave(channel: any, leave: any): void;
    _handleUnsubscribe(channel: any, unsubscribe: any): void;
    _handleSubscribe(channel: any, sub: any): void;
    _handleDisconnect(disconnect: any): void;
    _getPublicationContext(channel: any, pub: any): {
        channel: any;
        data: any;
    };
    _getJoinLeaveContext(clientInfo: any): {
        client: any;
        user: any;
    };
    _handlePublication(channel: any, pub: any): void;
    _handleMessage(message: any): void;
    _handleServerPing(next: any): void;
    _handlePush(data: any, next: any): void;
    _flush(): void;
    _createErrorObject(code: any, message: any, temporary: any): {
        code: any;
        message: any;
    };
    _registerCall(id: any, callback: any, errback: any): void;
    _addCommand(command: any): void;
    _nextPromiseId(): number;
    _resolvePromises(): void;
    _rejectPromises(err: any): void;
}
